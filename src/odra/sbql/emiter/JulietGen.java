package odra.sbql.emiter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Vector;

import odra.db.Database;
import odra.db.DatabaseException;
import odra.db.OID;
import odra.db.objects.data.DBModule;
import odra.db.objects.meta.MBClass;
import odra.db.objects.meta.MBEnum;
import odra.db.objects.meta.MBObject;
import odra.db.objects.meta.MBPrimitiveType;
import odra.db.objects.meta.MBProcedure;
import odra.db.objects.meta.MBStruct;
import odra.db.objects.meta.MBTypeDef;
import odra.db.objects.meta.MBVariable;
import odra.db.schema.OdraViewSchema;
import odra.sbql.ast.terminals.Operator;
import odra.sbql.emiter.instructions.Instruction;
import odra.transactions.metabase.ITransactionCapableMBObject;

//
/**
 * JulietGen utility class for generating pieces of Juliet byte code for SBQL
 * expressions and statements it is independend from the AST. The AST
 * codegenerators use this functionality but it can also be used in other way
 * 
 * @author radamus, tkowalsk
 * @version 1.0
 */

public final class JulietGen {

	// /////////////////////loading environments
	// //////////////////////////////////////
	/**
	 * generates code for loading global (current module) environment entry
	 * reference on top of the QRES
	 * 
	 * @return
	 */
	public static JulietCode genLoadPersistentEnvironment() {
		return new JulietCode().emit(OpCodes.ldE, 0);
	}

	/**
	 * generates code for loading global (module) environment entry reference
	 * 
	 * @param module
	 *            -the oid of the module to be loaded
	 * @return
	 */
	public static JulietCode genLoadPersistentEnvironment(OID module) {
		return new JulietCode().emit(OpCodes.ldE, module.internalOID());
	}

	/**
	 * generates code for loading module session environment entry reference on
	 * top of the QRES
	 * 
	 * @return
	 */
	public static JulietCode genLoadModuleSessionEnvironment() {
		return new JulietCode().emit(OpCodes.ldSE, 0);
	}

	/**
	 * generates code for loading module session environment entry reference on
	 * top of the QRES
	 * 
	 * @return
	 */
	public static JulietCode genLoadModuleSessionEnvironment(OID module) {
		return new JulietCode().emit(OpCodes.ldSE, module.internalOID());
	}

	/**
	 * generates code for loading local environment entry reference on top of
	 * the QRES
	 * 
	 * @return
	 */
	public static JulietCode genLoadLocalEnvironment() {
		return new JulietCode().emit(OpCodes.ldLE);
	}

	///////////////////////QRES/////////////////////////////////////////////////
	// /////
	/**
	 * generates code to pop QRES
	 * 
	 * @return
	 */
	public static JulietCode genPopQRES() {
		return new JulietCode().emit(OpCodes.pop);
	}

	//////////////////////create////////////////////////////////////////////////
	// /////
	// Creates Juliet code responsible for object creation.
	// Uses an object declaration (the "decl" parameter) stored in a module's
	// metabase.
	// The code generated by this method assumes that the topmost element of
	// qres
	// takes the form of a reference to the parent complex object.
	public static JulietCode genInitVariable(MBVariable decl, int minCard, int maxCard) throws DatabaseException {
		JulietCode resJt = new JulietCode();
		JulietCode instanceofinit = new JulietCode();

		int objnameid = decl.getNameId();
		if (decl.isTypeClass()) {
			instanceofinit.append(createInstanceofReference(decl.getType().getObjectNameId()));
		}

		if (minCard != 1 || maxCard != 1) {
			// resJt.emit(OpCodes.dup);
			resJt.emit(OpCodes.ldI, maxCard);
			resJt.emit(OpCodes.ldI, minCard);
			resJt.emit(OpCodes.crAggCard, objnameid);
			resJt.append(instanceofinit);
			// resJt.emit(OpCodes.pop);
		}

		return resJt;
	}

	public static JulietCode genCreateLocalEnvironment() {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.crLE);
		return resJt;
	}

	public static JulietCode genInitLocalEnvironment() {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.initLoc);
		return resJt;
	}

	public static JulietCode genDestroyLocalEnvironment() {
		// JulietCode resJt = JulietGen.genLoadLocalEnvironment();
		// resJt.emit(OpCodes.del);
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.dsEnv);
		return resJt;
	}

	public static JulietCode genInsertCopyExpression(MBVariable decl, int minCard, int maxCard, boolean safe) throws DatabaseException {
		JulietCode resJt = new JulietCode();

		resJt.append(createObjectWithInit(decl, minCard, maxCard, OpCodes.pop, new CreateProperties(safe, true, false, false, OpCodes.pop)));
		// result
		resJt.emit(OpCodes.pop);
		resJt.append(JulietGen.genEmptyBag());
		return resJt;
	}

	public static JulietCode genDynInsertCopyExpression(int nameid, JulietCode whereCode, JulietCode initCode) {
		JulietCode resJt = JulietGen.genDynamicCreate(nameid, whereCode, initCode);
		resJt.emit(OpCodes.pop);
		return resJt.append(JulietGen.genEmptyBag());

	}

	public static JulietCode genCreateExpressionDefault(MBVariable decl) throws DatabaseException {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.bindAgg, decl.getNameId());
		return resJt.append(JulietGen.genCreateForType(decl.getType(), decl.getNameId(), false, true));
	}

	public static JulietCode genCreateExpressionWithInit(MBVariable decl, int minCard, int maxCard) throws DatabaseException {
		JulietCode resJt = new JulietCode();
		JulietCode appendJt = new JulietCode();
		if (minCard != 1 || maxCard != 1) {
			resJt.emit(OpCodes.ldBag);
			resJt.emit(OpCodes.swap);
			appendJt.emit(OpCodes.pop);
		}
		resJt.emit(OpCodes.bindAgg, decl.getNameId());
		resJt.append(createObjectWithInit(decl, minCard, maxCard, OpCodes.insPrt3, new CreateProperties(true, false, false, true, OpCodes.insPrt3)));
		return resJt.append(appendJt);
	}

	public static JulietCode genCreateDefaultPermanentExpression(MBVariable decl, boolean currentModule) throws DatabaseException {
		JulietCode resJt = new JulietCode();
		if (currentModule) {
			resJt.append(JulietGen.genLoadPersistentEnvironment());
		} else {
			resJt.append(JulietGen.genLoadPersistentEnvironment(decl.getModule().getOID()));
		}
		return resJt.append(JulietGen.genCreateForType(decl.getType(), decl.getNameId(), true, true));

	}

	public static JulietCode genCreatePermanentExpression(MBVariable decl, int minCard, int maxCard, boolean currentModule, boolean safe)
			throws DatabaseException {
		JulietCode resJt = new JulietCode();
		JulietCode appendJt = new JulietCode();

		if (minCard != 1 || maxCard != 1) {
			resJt.emit(OpCodes.ldBag);
			resJt.emit(OpCodes.swap);
			appendJt.emit(OpCodes.pop);
		}
		if (currentModule) {
			resJt.append(JulietGen.genLoadPersistentEnvironment());
		} else {
			resJt.append(JulietGen.genLoadPersistentEnvironment(decl.getModule().getOID()));
		}
		resJt.append(createObjectWithInit(decl, minCard, maxCard, OpCodes.insPrt3, new CreateProperties(safe, true, false, false, OpCodes.insPrt3)));

		resJt.append(appendJt);
		return resJt;

	}

	public static JulietCode genCreateDefaultTemporalExpression(MBVariable decl, boolean currentModule) throws DatabaseException {
		JulietCode resJt = new JulietCode();

		if (currentModule) {
			resJt.append(JulietGen.genLoadModuleSessionEnvironment());
		} else {
			resJt.append(JulietGen.genLoadModuleSessionEnvironment(decl.getModule().getOID()));
		}
		return resJt.append(JulietGen.genCreateForType(decl.getType(), decl.getNameId(), true, true));

	}

	public static JulietCode genCreateTemporalExpression(MBVariable decl, int minCard, int maxCard, boolean currentModule, boolean safe)
			throws DatabaseException {
		JulietCode resJt = new JulietCode();
		JulietCode appendJt = new JulietCode();

		if (minCard != 1 || maxCard != 1) {
			resJt.emit(OpCodes.ldBag);
			resJt.emit(OpCodes.swap);
			appendJt.emit(OpCodes.pop);
		}
		if (currentModule) {
			resJt.append(JulietGen.genLoadModuleSessionEnvironment());
		} else {
			resJt.append(JulietGen.genLoadModuleSessionEnvironment(decl.getModule().getOID()));
		}
		resJt.append(createObjectWithInit(decl, minCard, maxCard, OpCodes.insPrt3, new CreateProperties(safe, true, false, false, OpCodes.insPrt3)));

		resJt.append(appendJt);
		return resJt;

	}

	public static JulietCode genCreateDefaultLocalExpression(MBVariable decl) throws DatabaseException {
		JulietCode resJt = new JulietCode();

		resJt.append(JulietGen.genLoadLocalEnvironment());
		return resJt.append(JulietGen.genCreateForType(decl.getType(), decl.getNameId(), true, true));

	}

	public static JulietCode genCreateLocalExpression(MBVariable decl, int minCard, int maxCard, boolean safe) throws DatabaseException {
		JulietCode resJt = new JulietCode();
		JulietCode appendJt = new JulietCode();

		if (minCard != 1 || maxCard != 1) {
			resJt.emit(OpCodes.ldBag);
			resJt.emit(OpCodes.swap);
			appendJt.emit(OpCodes.pop);
		}
		resJt.append(JulietGen.genLoadLocalEnvironment());
		resJt.append(createObjectWithInit(decl, minCard, maxCard, OpCodes.insPrt3, new CreateProperties(safe, true, false, false, OpCodes.insPrt3)));

		resJt.append(appendJt);
		return resJt;

	}

	public static JulietCode genDeleteExpression(JulietCode jtCode) {
		JulietCode resJt = new JulietCode(jtCode);
		JulietCode inLoop = new JulietCode();
		inLoop.emit(OpCodes.del);
		// inLoop.emit(OpCodes.pop);
		resJt.append(JulietGen.genIterationWithCounter(inLoop));
		// empty bag as result
		resJt.emit(OpCodes.ldBag);
		return resJt;
	}

	public static JulietCode genVirtualCreate(int name, JulietCode rJtCode) throws DatabaseException {

		JulietCode resJt = new JulietCode();

		resJt.emit(OpCodes.ldI, 1); // on_new has one param
		resJt.emit(OpCodes.swap);

		resJt.emit(OpCodes.ldvGenPrc, Database.getStore().addName(OdraViewSchema.GenericNames.ON_NEW_NAME.toString()));
		resJt.append(JulietGen.genProcedureCall());

		return resJt.emit(OpCodes.retSub); // subroutine return

	}

	public static JulietCode genVirtualCreate(int name, JulietCode rJtCode, OID module) {
		JulietCode resJt = new JulietCode();
		if (module == null)
			resJt.append(JulietGen.genLoadPersistentEnvironment());
		else
			resJt.append(JulietGen.genLoadPersistentEnvironment(module));
		resJt.append(rJtCode);
		resJt.emit(OpCodes.crDyn, name).emit(OpCodes.fltn);
		return resJt;
	}

	public static JulietCode genDynamicPermanentCreate(int name, JulietCode rJtCode, OID module) {
		if (module == null)
			return JulietGen.genDynamicCreate(name, JulietGen.genLoadPersistentEnvironment(), rJtCode);
		return JulietGen.genDynamicCreate(name, JulietGen.genLoadPersistentEnvironment(module), rJtCode);
	}

	public static JulietCode genDynamicLocalCreate(int name, JulietCode rJtCode) {

		return JulietGen.genDynamicCreate(name, JulietGen.genLoadLocalEnvironment(), rJtCode);
	}

	public static JulietCode genDynamicTemporalCreate(int name, JulietCode rJtCode) {

		return JulietGen.genDynamicCreate(name, JulietGen.genLoadModuleSessionEnvironment(), rJtCode);
	}

	public static JulietCode genDynamicCreate(int name, JulietCode lJtCode, JulietCode rJtCode) {
		JulietCode resJt = new JulietCode(lJtCode);
		resJt.append(JulietGen.genDynDeref(rJtCode));
		return resJt.emit(OpCodes.crDyn, name).emit(OpCodes.fltn);
	}

	public static JulietCode genCreate(MBVariable decl) throws DatabaseException {
		return genCreate(decl, false);
	}
	/**
	 * @param decl
	 * @param leaveResultOnQRES - if true the result of create operation is left on top of QRES 
	 * @return
	 * @throws DatabaseException
	 */
	public static JulietCode genCreate(MBVariable decl, boolean leaveResultOnQRES) throws DatabaseException {
		JulietCode resJt = new JulietCode();

		int objnameid = decl.getNameId();
		int minCard = decl.getMinCard();
		int maxCard = decl.getMaxCard();

		if (minCard != 1 || maxCard != 1) {
			resJt.emit(OpCodes.dup);
			resJt.emit(OpCodes.fnd, objnameid);
			resJt.emit(OpCodes.dup);
			resJt.append(JulietGen.genConditionalExpression(new JulietCode().emit(OpCodes.exist), new JulietCode().emit(OpCodes.swap).emit(
					OpCodes.pop), new JulietCode().emit(OpCodes.pop).emit(OpCodes.dup).emit(OpCodes.ldI, maxCard).emit(OpCodes.ldI, minCard).emit(
					OpCodes.crAggCard, objnameid)));

		}
		if (decl.getRefIndicator() == 0)
			resJt.append(JulietGen.genCreateForType(decl.getType(), objnameid, false, leaveResultOnQRES));
		else {
			resJt.append(JulietGen.genCreateForReferenceType(objnameid, leaveResultOnQRES));

		}
		
		/////////////
		//if(((new MBObject(decl.getType())).getObjectKind()).name().equals("ENUM_OBJECT")){
			//int i=0;
		//}tu tez wchodzimy
		////////////

		return resJt;
	}

	private static JulietCode genCreateForType(OID typeid, int objnameid, boolean aggregate, boolean leaveResultOnQRES) throws DatabaseException {

		switch (new MBObject(typeid).getObjectKind()) {
		case PRIMITIVE_TYPE_OBJECT:
			return genCreateForPrimitiveType(typeid, objnameid, leaveResultOnQRES);

		case STRUCT_OBJECT:
			return genCreateForStructType(typeid, objnameid, aggregate, leaveResultOnQRES);

		case TYPEDEF_OBJECT:
			return genCreateForTypeDef(typeid, objnameid, aggregate, leaveResultOnQRES);
		case CLASS_OBJECT:
			return genCreateForClassType(typeid, objnameid, aggregate, leaveResultOnQRES);
		case ENUM_OBJECT:
			return genCreateForEnumType(typeid, objnameid, aggregate, leaveResultOnQRES);
		default:
			assert false : "unimplemented type";
			return null;
		}

	}

	private static JulietCode genCreateForClassType(OID typeid, int objnameid, boolean aggregate, boolean leaveResultOnQRES) throws DatabaseException {
		MBClass type = new MBClass(typeid);
		Vector<OID> types = type.getFullType();

		return genCreateForClassInheritanceStructTypes(types.toArray(new OID[types.size()]), objnameid, typeid.getObjectNameId(), aggregate,
				leaveResultOnQRES);
	}

	private static JulietCode genCreateForEnumType(OID typeid, int objnameid, boolean aggregate, boolean leaveResultOnQRES) throws DatabaseException {
		
		MBEnum type = new MBEnum(typeid);
		DBModule mod = type.getModule();
		return genCreateForType(mod.getCompiledMetaReferenceAt(type.getTypeNameId()).derefReference(), objnameid, aggregate, leaveResultOnQRES);
	}

	private static JulietCode genCreateForTypeDef(OID typeid, int objnameid, boolean aggregate, boolean leaveResultOnQRES) throws DatabaseException {
		MBTypeDef type = new MBTypeDef(typeid);
		DBModule mod = type.getModule();

		// JulietCode jc = new JulietCode();

		return genCreateForType(mod.getCompiledMetaReferenceAt(type.getTypeNameId()).derefReference(), objnameid, aggregate, leaveResultOnQRES);
	}

	private static JulietCode genCreateForReferenceType(int objnameid, boolean leaveResultOnQRES) {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.crRef, objnameid);
		if (!leaveResultOnQRES)
			resJt.emit(OpCodes.pop);
		return resJt;
	}

	private static JulietCode genCreateForPrimitiveType(OID typeid, int objnameid, boolean leaveResultOnQRES) throws DatabaseException {
		JulietCode resJt = new JulietCode();

		MBPrimitiveType type = new MBPrimitiveType(typeid);

		switch (type.getTypeKind()) {
		case BOOLEAN_TYPE:
			resJt.emit(OpCodes.crB, objnameid);
			break;
		case INTEGER_TYPE:
			resJt.emit(OpCodes.crI, objnameid);
			break;
		case REAL_TYPE:
			resJt.emit(OpCodes.crR, objnameid);
			break;
		case STRING_TYPE:
			resJt.emit(OpCodes.crS, objnameid);
			break;
		case DATE_TYPE:
			resJt.emit(OpCodes.crD, objnameid);
			break;
		default:
			assert false : "unknown primitive type";
		}
		if (!leaveResultOnQRES)
			resJt.emit(OpCodes.pop);

		return resJt;
	}

	private static JulietCode genCreateForStructType(OID typeid, int objnameid, boolean aggregate, boolean leaveResultOnQRES)
			throws DatabaseException {
		JulietCode resJt = new JulietCode();

		MBStruct type = new MBStruct(typeid);
		resJt.emit(aggregate ? OpCodes.crAggCpx : OpCodes.crCpx, objnameid);

		OID[] fields = type.getFields();
		for (int i = 0; i < fields.length; i++) {
			MBVariable fieldvar = new MBVariable(fields[i]);
			// /
			// initialization
			resJt.emit(OpCodes.dup);
			resJt.append(JulietGen.genInitVariable(fieldvar, fieldvar.getMinCard(), fieldvar.getMaxCard()));
			resJt.emit(OpCodes.pop);

			// /
			if (fieldvar.getMinCard() > 0) {
				resJt.emit(OpCodes.dup);

				resJt.append(genCreate(fieldvar));
			}
		}
		if (!leaveResultOnQRES)
			resJt.emit(OpCodes.pop);

		return resJt;
	}

	private static JulietCode genCreateForClassInheritanceStructTypes(OID[] typeids, int objnameid, int classnameid, boolean aggregate,
			boolean leaveResultOnQRES) throws DatabaseException {
		JulietCode resJt = new JulietCode();

		resJt.emit(aggregate ? OpCodes.crAggCpx : OpCodes.crCpx, objnameid);
		resJt.append(createInstanceofReference(classnameid));

		for (OID typeid : typeids) {
			MBStruct type = new MBStruct(typeid);
			OID[] fields = type.getFields();
			for (OID field : fields) {
				MBVariable fieldvar = new MBVariable(field);
				// /
				// initialization
				resJt.emit(OpCodes.dup);
				resJt.append(JulietGen.genInitVariable(fieldvar, fieldvar.getMinCard(), fieldvar.getMaxCard()));
				resJt.emit(OpCodes.pop);

				// /
				if (fieldvar.getMinCard() > 0) {
					resJt.emit(OpCodes.dup);

					resJt.append(genCreate(fieldvar));
				}
			}
		}
		if (!leaveResultOnQRES)
			resJt.emit(OpCodes.pop);

		return resJt;
	}

	/**
	 * Generate Juliet code for procedure parameters runtime initialization
	 * version where params are binders not a local variables
	 * 
	 * @param decl
	 * @return
	 * @throws JulietCodeGeneratorException
	 */

	private static JulietCode genInitProcedureParams(OID[] args, boolean safe) throws DatabaseException {
		JulietCode jtCd = new JulietCode();

		for (int i = args.length - 1; i >= 0; i--) {
			if (!safe)
				jtCd.emit(OpCodes.dynDeref);
			jtCd.emit(OpCodes.enterBinder, args[i].getObjectNameId());

		}
		return jtCd;

	}

	// /**
	// * Generate Juliet code for procedure parameter runtime initialization
	// version where param is a local variable
	// * currently unused
	// *
	// * @deprecated we currently treat parameters as binders
	// * @param decl
	// * @return
	// * @throws JulietCodeGeneratorException
	// */

	// private static JulietCode genInitProcedureParam(MBVariable decl, boolean
	// safe) throws JulietCodeGeneratorException {
	//
	// try {
	// return createObjectWithInit(decl, decl.getMinCard(), decl.getMaxCard(),
	// OpCodes.pop, safe, false).emit(
	// OpCodes.pop);
	// } catch (DatabaseException e) {
	// throw new JulietCodeGeneratorException("Code generator error: " +
	// e.getMessage(), e);
	// }
	//
	// }

	private static JulietCode createObjectWithInit(MBVariable decl, int minCard, int maxCard, OpCodes refOpcode, CreateProperties properties)
			throws DatabaseException {
		assert properties.createOnlyInterior == false || (minCard == 1 && maxCard == 1) : "createOnlyInterior mode works only for singular cardinality";

		JulietCode resJt = new JulietCode();

		if (properties.marked.containsKey(decl.getOID())) {

			Instruction end = new Instruction(OpCodes.nop);

			resJt.emit(OpCodes.lRet, end);
			resJt.emit(OpCodes.bra, properties.marked.get(decl.getOID()));
			resJt.emit(end);

		} else {

			Instruction start = new Instruction(OpCodes.nop);
			Instruction end = new Instruction(OpCodes.nop);

			resJt.emit(OpCodes.lRet, end);
			resJt.emit(start);

			if (!properties.createOnlyInterior)
				properties.marked.put(decl.getOID(), start);

			int objnameid = decl.getOID().getObjectNameId();
			if (decl.getRefIndicator() == 0) {
				if (decl.isTypePrimitive()) {
					assert properties.createOnlyInterior == false : "primitive type object cannot be created in createOnlyInterior mode";
					resJt.append(createPrimitiveTypeObjectWithInit(decl.getType(), minCard, maxCard, objnameid, properties));

				} else if (decl.isTypeStruct()) {
					resJt.append(createComplexTypeObjectWithInit(decl.getType(), minCard, maxCard, objnameid, properties));

				} else if (decl.isTypeTypeDef()) {
					resJt.append(createTypeDefTypeObjectWithInit(decl.getType(), minCard, maxCard, objnameid, properties));
				} else if (decl.isTypeClass()) {
					MBClass type = new MBClass(decl.getType());
					resJt.append(createClassTypeObjectWithInit(decl.getType(), minCard, maxCard, objnameid, properties));

				} else if (decl.isTypeEnum()) {
					resJt.append(createEnumTypeObjectWithInit(decl.getType(), minCard, maxCard, objnameid, properties));
				} else {
					assert false : " unknown type of arguments: " + decl.getName();
				}
			} else if (decl.isTypeReference()) {
				if (decl.hasReverseReference()) {
					MBVariable revvar = new MBVariable(decl.getReversePointer());
					resJt.append(createReverseReferenceTypeObjectWithInit(minCard, maxCard, objnameid, decl.getReverseNameId(), properties, (revvar
							.getMinCard() != 1 || revvar.getMaxCard() != 1)));
				} else
					resJt.append(createReferenceTypeObjectWithInit(minCard, maxCard, objnameid, properties));
			} else
				assert false : "unimplemented variable type";

			resJt.emit(OpCodes.braRet);
			resJt.emit(end);

		}

		return resJt;
	}

	private static JulietCode createTypeDefTypeObjectWithInit(OID typeid, int minCard, int maxCard, int objnameid, CreateProperties properties)
			throws DatabaseException {
		MBTypeDef type = new MBTypeDef(typeid);
		DBModule mod = type.getModule();

		OID targetTypeID = mod.getCompiledMetaReferenceAt(type.getTypeNameId()).derefReference();
		switch (new MBObject(targetTypeID).getObjectKind()) {
		case PRIMITIVE_TYPE_OBJECT:
			return createPrimitiveTypeObjectWithInit(targetTypeID, minCard, maxCard, objnameid, properties);

		case STRUCT_OBJECT:
			return createComplexTypeObjectWithInit(targetTypeID, minCard, maxCard, objnameid, properties);

		case TYPEDEF_OBJECT:
			return createTypeDefTypeObjectWithInit(targetTypeID, minCard, maxCard, objnameid, properties);

		case CLASS_OBJECT:
			return createClassTypeObjectWithInit(targetTypeID, minCard, maxCard, objnameid, properties);

		default:
			assert false : "unsupported type" + new MBObject(targetTypeID).getObjectKind().toString();
			return null;
		}

	}

	private static JulietCode createEnumTypeObjectWithInit(OID typeid, int minCard, int maxCard, int objnameid, CreateProperties properties)
			throws DatabaseException {
		MBEnum type = new MBEnum(typeid);
		DBModule mod = type.getModule();

		OID targetTypeID = mod.getCompiledMetaReferenceAt(type.getTypeNameId()).derefReference();
		switch (new MBObject(targetTypeID).getObjectKind()) {
		case PRIMITIVE_TYPE_OBJECT:
			return createPrimitiveTypeObjectWithInit(targetTypeID, minCard, maxCard, objnameid, properties);

		case STRUCT_OBJECT:
			return createComplexTypeObjectWithInit(targetTypeID, minCard, maxCard, objnameid, properties);

		case TYPEDEF_OBJECT:
			return createTypeDefTypeObjectWithInit(targetTypeID, minCard, maxCard, objnameid, properties);

		case CLASS_OBJECT:
			return createClassTypeObjectWithInit(targetTypeID, minCard, maxCard, objnameid, properties);

		default:
			assert false : "unsupported type" + new MBObject(targetTypeID).getObjectKind().toString();
			return null;
		}

	}

	/**
	 * Generates code for creating a reference type object/objects an initialize
	 * it with vaule/values taken from the QRES
	 * 
	 * @param minCard
	 * @param maxCard
	 * @param objnameid
	 * @param safe
	 * @return
	 * @throws JulietCodeGeneratorException
	 */
	private static JulietCode createReferenceTypeObjectWithInit(int minCard, int maxCard, int objnameid, CreateProperties properties) {
		JulietCode resJt = new JulietCode();
		if (isSingle(minCard, maxCard)) {
			if (properties.aggregateOnTheStack) {
				resJt.emit(OpCodes.crRef, objnameid);
			} else
				resJt.emit(properties.alwaysAggregate ? OpCodes.crAggRef : OpCodes.crRef, objnameid);
			resJt.emit(OpCodes.storeRef);
		} else { // cardinality <> 1
			Instruction loop = new Instruction(OpCodes.endCntr);
			Instruction end = new Instruction(OpCodes.pop);

			if (!properties.aggregateOnTheStack) {
				resJt.emit(OpCodes.ldI, minCard);
				resJt.emit(OpCodes.crAgg, objnameid);
			}
			resJt.emit(OpCodes.swap);
			resJt.append(JulietGen.createCounter());
			resJt.emit(loop);
			resJt.emit(OpCodes.braTrue, end);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.dup_x1);
			resJt.emit(OpCodes.crRef, objnameid);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.ldCntr);
			resJt.emit(OpCodes.extr);
			resJt.emit(OpCodes.bswap2);
			resJt.emit(OpCodes.storeRef);
			resJt.emit(properties.resultOpCode);
			resJt.emit(OpCodes.incCntr);
			resJt.emit(OpCodes.bra, loop);
			resJt.emit(end);
			resJt.append(JulietGen.destroyCounter());

		}
		return resJt;
	}

	/**
	 * Generates code for creating a reference type object/objects an initialize
	 * it with vaule/values taken from the QRES
	 * 
	 * @param minCard
	 * @param maxCard
	 * @param objnameid
	 * @param safe
	 * @return
	 * @throws JulietCodeGeneratorException
	 */
	private static JulietCode createReverseReferenceTypeObjectWithInit(int minCard, int maxCard, int objnameid, int revnameid,
			CreateProperties properties, boolean reverseAggregate) {
		assert properties != null : "properties != null";
		assert !properties.aggregateOnTheStack : "properties.aggregateOnTheStack == false";
		JulietCode resJt = new JulietCode();
		if (isSingle(minCard, maxCard)) {
			resJt.emit(OpCodes.dup);
			resJt.emit(properties.alwaysAggregate ? OpCodes.crAggRef : OpCodes.crRef, objnameid);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.bswap2);
			resJt.emit(OpCodes.dup);
			if (reverseAggregate)
				resJt.emit(OpCodes.crAggRef, revnameid);
			else
				resJt.emit(OpCodes.fnd, revnameid);

			resJt.emit(OpCodes.bswap2);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.storeRef);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.bswap2);
			resJt.emit(OpCodes.storeRef);
			resJt.emit(OpCodes.dup);
			resJt.emit(OpCodes.bswap2);
			resJt.emit(OpCodes.storeRevRef);
		} else { // cardinality <> 1
			Instruction loop = new Instruction(OpCodes.endCntr);
			Instruction end = new Instruction(OpCodes.pop);

			resJt.emit(OpCodes.swap);
			resJt.append(JulietGen.createCounter());
			resJt.emit(loop);
			resJt.emit(OpCodes.braTrue, end);
			// loop
			resJt.emit(OpCodes.ldCntr);
			resJt.emit(OpCodes.extr);
			if (reverseAggregate)
				resJt.emit(OpCodes.crAggRef, revnameid);
			else
				resJt.emit(OpCodes.fnd, revnameid);
			resJt.emit(OpCodes.bswap2);
			resJt.emit(OpCodes.dup_x2);

			resJt.emit(OpCodes.crAggRef, objnameid);
			resJt.emit(OpCodes.dup2);
			resJt.emit(OpCodes.storeRevRef);
			resJt.emit(OpCodes.bswap2);
			resJt.emit(OpCodes.ldCntr);
			resJt.emit(OpCodes.extr);
			resJt.emit(OpCodes.bswap2);
			resJt.emit(OpCodes.storeRef);
			resJt.emit(OpCodes.pop);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.bswap2);
			resJt.emit(OpCodes.dup_x2);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.storeRef);
			resJt.emit(properties.resultOpCode);
			resJt.emit(OpCodes.incCntr);
			resJt.emit(OpCodes.bra, loop);
			resJt.emit(end);
			resJt.append(JulietGen.destroyCounter());

		}
		return resJt;
	}

	/**
	 * Generates code for creating a primitive type object/objects an initialize
	 * it with vaule/values taken from the QRES
	 * 
	 * @param typeid
	 * @param minCard
	 * @param maxCard
	 * @param objnameid
	 * @param safe
	 * @return
	 * @throws JulietCodeGeneratorException
	 * @throws DatabaseException
	 */
	private static JulietCode createPrimitiveTypeObjectWithInit(OID typeid, int minCard, int maxCard, int objnameid, CreateProperties properties)
			throws DatabaseException {

		JulietCode resJt = new JulietCode();
		MBPrimitiveType type = new MBPrimitiveType(typeid);

		if (minCard == 1 && maxCard == 1) {
			if (!properties.safe) {
				resJt.emit(OpCodes.swap);
				resJt.emit(OpCodes.single);
				resJt.emit(OpCodes.dynDeref);
			}
			switch (type.getTypeKind()) {
			case BOOLEAN_TYPE:
				resJt.append(initSinglePrimitiveObject(properties, OpCodes.dyn2b, OpCodes.crAggB, OpCodes.crB, OpCodes.storeB, objnameid));
				break;
			case INTEGER_TYPE:
				resJt.append(initSinglePrimitiveObject(properties, OpCodes.dyn2i, OpCodes.crAggI, OpCodes.crI, OpCodes.storeI, objnameid));
				break;
			case REAL_TYPE:
				resJt.append(initSinglePrimitiveObject(properties, OpCodes.dyn2r, OpCodes.crAggR, OpCodes.crR, OpCodes.storeR, objnameid));
				break;
			case STRING_TYPE:
				resJt.append(initSinglePrimitiveObject(properties, OpCodes.dyn2s, OpCodes.crAggS, OpCodes.crS, OpCodes.storeS, objnameid));
				break;
			case DATE_TYPE:
				resJt.append(initSinglePrimitiveObject(properties, OpCodes.dyn2d, OpCodes.crAggD, OpCodes.crD, OpCodes.storeD, objnameid));
				break;
			default:
				assert false : "unknown primitive type" + type.getTypeKind().toString();
				break;
			}

		} else { // cardinality <> 1
			Instruction loop = new Instruction(OpCodes.endCntr);
			Instruction end = new Instruction(OpCodes.pop);
			JulietCode storeCode = new JulietCode();

			if (!properties.aggregateOnTheStack) {
				resJt.emit(OpCodes.ldI, minCard);
				resJt.emit(OpCodes.crAgg, objnameid);
			}
			resJt.emit(OpCodes.swap);
			resJt.append(JulietGen.createCounter());
			resJt.emit(loop);
			resJt.emit(OpCodes.braTrue, end);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.dup_x1);
			switch (type.getTypeKind()) {
			case BOOLEAN_TYPE:
				resJt.append(initCollectionOfPrimitiveObjects(properties, storeCode, OpCodes.dyn2b, OpCodes.crB, OpCodes.storeB, objnameid));
				break;
			case INTEGER_TYPE:
				resJt.append(initCollectionOfPrimitiveObjects(properties, storeCode, OpCodes.dyn2i, OpCodes.crI, OpCodes.storeI, objnameid));
				break;
			case REAL_TYPE:
				resJt.append(initCollectionOfPrimitiveObjects(properties, storeCode, OpCodes.dyn2r, OpCodes.crR, OpCodes.storeR, objnameid));
				break;
			case STRING_TYPE:
				resJt.append(initCollectionOfPrimitiveObjects(properties, storeCode, OpCodes.dyn2s, OpCodes.crS, OpCodes.storeS, objnameid));
				break;
			case DATE_TYPE:
				resJt.append(initCollectionOfPrimitiveObjects(properties, storeCode, OpCodes.dyn2d, OpCodes.crD, OpCodes.storeD, objnameid));
				break;
			default:
				assert false : "unknown primitive type";
				storeCode.emit(OpCodes.pop);
				break;
			}

			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.ldCntr);
			resJt.emit(OpCodes.extr);
			resJt.emit(OpCodes.bswap2);
			resJt.append(storeCode);
			resJt.emit(properties.resultOpCode);
			resJt.emit(OpCodes.incCntr);
			resJt.emit(OpCodes.bra, loop);
			resJt.emit(end);
			resJt.append(JulietGen.destroyCounter());
		}
		return resJt;
	}

	/**
	 * @param properties
	 * @param dynCastOpCode
	 * @param createAggOpCode
	 * @param createSingleOpCode
	 * @param storeOpCode
	 * @param objnameid
	 * @param single
	 * @return
	 */
	private static JulietCode initSinglePrimitiveObject(CreateProperties properties, OpCodes dynCastOpCode, OpCodes createAggOpCode,
			OpCodes createSingleOpCode, OpCodes storeOpCode, int objnameid) {
		JulietCode resJt = new JulietCode();

		if (!properties.safe) {
			resJt.emit(dynCastOpCode);
			resJt.emit(OpCodes.swap);
		}
		if (properties.aggregateOnTheStack) {
			resJt.emit(createSingleOpCode, objnameid);
		} else
			resJt.emit(properties.alwaysAggregate ? createAggOpCode : createSingleOpCode, objnameid);

		resJt.emit(storeOpCode);

		return resJt;
	}

	private static JulietCode initCollectionOfPrimitiveObjects(CreateProperties properties, JulietCode storeCode, OpCodes dynCastOpCode,
			OpCodes createOpCode, OpCodes storeOpCode, int objnameid) {
		JulietCode resJt = new JulietCode();

		if (!properties.safe) {
			storeCode.emit(OpCodes.swap);
			storeCode.emit(OpCodes.dynDeref);
			storeCode.emit(dynCastOpCode);
			storeCode.emit(OpCodes.swap);
		}
		storeCode.emit(storeOpCode);
		resJt.emit(createOpCode, objnameid);
		return resJt;
	}

	/**
	 * Generates code for creating a complex type object/objects an initialize
	 * it with vaule/values taken from the QRES
	 * 
	 * @param typeid
	 * @param minCard
	 * @param maxCard
	 * @param objnameid
	 * @param safe
	 *            - do we generate it against typechecker environment
	 * @param alwaysAggregate
	 *            - should we always create aggregate (no matter the
	 *            cardinality)
	 * @return
	 * @throws JulietCodeGeneratorException
	 * @throws DatabaseException
	 */
	private static JulietCode createComplexTypeObjectWithInit(OID typeid, int minCard, int maxCard, int objnameid, CreateProperties properties)
			throws DatabaseException {
		JulietCode resJt = new JulietCode();
		MBStruct type = new MBStruct(typeid);
		OID[] fields = type.getFields();
		if (isSingle(minCard, maxCard)) {
			resJt.emit(OpCodes.swap);
			resJt.append(createNestedEnvironment());
			if (!properties.createOnlyInterior) {
				if (properties.aggregateOnTheStack) {
					resJt.emit(OpCodes.crCpx, objnameid);
				} else
					resJt.emit(properties.alwaysAggregate ? OpCodes.crAggCpx : OpCodes.crCpx, objnameid);
			}

			for (OID field : fields) {
				MBVariable mbfield = new MBVariable(field);
				resJt.append(genInitializeStructureField(mbfield, properties));
			}
			resJt.append(destroyNestedEnvironment());
		} else { // cardinality <> 1
			Instruction loop = new Instruction(OpCodes.endCntr);
			Instruction end = new Instruction(OpCodes.pop);
			if (!properties.aggregateOnTheStack) {
				resJt.emit(OpCodes.ldI, minCard);
				resJt.emit(OpCodes.crAgg, objnameid);
			}
			resJt.emit(OpCodes.swap);
			resJt.append(JulietGen.createCounter());
			resJt.emit(loop);
			resJt.emit(OpCodes.braTrue, end);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.dup_x1);
			resJt.emit(OpCodes.crCpx, objnameid);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.ldCntr);
			resJt.emit(OpCodes.extr);
			resJt.append(createNestedEnvironment());
			resJt.emit(OpCodes.swap);
			for (OID field : fields) {
				MBVariable mbfield = new MBVariable(field);
				resJt.append(genInitializeStructureField(mbfield, properties));
			}
			resJt.emit(properties.resultOpCode);
			resJt.append(destroyNestedEnvironment());
			resJt.emit(OpCodes.incCntr);
			resJt.emit(OpCodes.bra, loop);
			resJt.emit(end);
			resJt.append(JulietGen.destroyCounter());
		}
		return resJt;
	}

	/**
	 * @param mbfield
	 * @param marked
	 * @param alwaysAggregate
	 * @param safe
	 * @return
	 * @throws DatabaseException
	 */
	private static JulietCode genInitializeStructureField(MBVariable mbfield, CreateProperties properties) throws DatabaseException {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.dup);
		// /
		// initialization
		resJt.append(JulietGen.genInitVariable(mbfield, mbfield.getMinCard(), mbfield.getMaxCard()));
		resJt.emit(OpCodes.pop);
		resJt.emit(OpCodes.dup);

		resJt.emit(OpCodes.bindTop, mbfield.getOID().getObjectNameId());
		resJt.emit(OpCodes.swap);
		// new properties because some of them needs to be changed
		properties = new CreateProperties(properties.safe, false, false, false, OpCodes.pop, properties.marked);
		resJt.append(createObjectWithInit(mbfield, mbfield.getMinCard(), mbfield.getMaxCard(), OpCodes.pop, properties));
		resJt.emit(OpCodes.pop);
		return resJt;
	}

	/**
	 * Generates code for creating a complex type object/objects an initialize
	 * it with vaule/values taken from the QRES
	 * 
	 * @param typeid
	 * @param minCard
	 * @param maxCard
	 * @param objnameid
	 * @param safe
	 *            - do we generate it against typechecker environment
	 * @param alwaysAggregate
	 *            - should we always create aggregate (no matter the
	 *            cardinality)
	 * @return
	 * @throws JulietCodeGeneratorException
	 * @throws DatabaseException
	 */
	private static JulietCode createClassTypeObjectWithInit(OID typeid, int minCard, int maxCard, int objnameid, CreateProperties properties)
			throws DatabaseException {
		JulietCode resJt = new JulietCode();
		MBClass mbclass = new MBClass(typeid);
		int classNameId = mbclass.getNameId();
		Vector<OID> types = mbclass.getFullType();
		Vector<OID> cfields = new Vector<OID>();
		for (OID ctype : types) {
			MBStruct type = new MBStruct(ctype);
			for (OID field : type.getFields()) {
				cfields.add(field);
			}
		}

		if (isSingle(minCard, maxCard)) {
			resJt.emit(OpCodes.swap);
			resJt.append(createNestedEnvironment());
			if (!properties.createOnlyInterior) {
				if (properties.aggregateOnTheStack) {
					resJt.emit(OpCodes.crCpx, objnameid);
				} else {
					resJt.emit(properties.alwaysAggregate ? OpCodes.crAggCpx : OpCodes.crCpx, objnameid);
				}
				resJt.append(createInstanceofReference(classNameId));
			}
			for (OID field : cfields) {
				MBVariable mbfield = new MBVariable(field);
				resJt.append(genInitializeStructureField(mbfield, properties));
			}
			resJt.append(destroyNestedEnvironment());
		} else { // cardinality <> 1
			Instruction loop = new Instruction(OpCodes.endCntr);
			Instruction end = new Instruction(OpCodes.pop);
			if (!properties.aggregateOnTheStack) {
				resJt.emit(OpCodes.ldI, minCard);
				resJt.emit(OpCodes.crAgg, objnameid);
			}
			resJt.emit(OpCodes.swap);
			resJt.append(JulietGen.createCounter());
			resJt.emit(loop);
			resJt.emit(OpCodes.braTrue, end);
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.dup_x1);
			resJt.emit(OpCodes.crCpx, objnameid);
			resJt.append(createInstanceofReference(classNameId));
			resJt.emit(OpCodes.swap);
			resJt.emit(OpCodes.ldCntr);
			resJt.emit(OpCodes.extr);
			resJt.append(createNestedEnvironment());
			resJt.emit(OpCodes.swap);
			for (OID field : cfields) {
				MBVariable mbfield = new MBVariable(field);
				resJt.append(genInitializeStructureField(mbfield, properties));
			}
			resJt.emit(properties.resultOpCode);
			resJt.append(destroyNestedEnvironment());
			resJt.emit(OpCodes.incCntr);
			resJt.emit(OpCodes.bra, loop);
			resJt.emit(end);
			resJt.append(JulietGen.destroyCounter());
		}
		return resJt;
	}

	/**
	 * Create instanceof reference for the top QRES reference
	 * 
	 * @param nameId
	 *            - class name id
	 * @return
	 */
	private static JulietCode createInstanceofReference(int nameId) {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.bind, nameId);
		resJt.emit(OpCodes.swap);
		resJt.emit(OpCodes.crInstRef);
		return resJt;
	}

	/**
	 * Generates Juliet code for procedure header (local store initialization,
	 * parameters)
	 * 
	 * @param decl
	 *            metabase procedure object
	 * @return - procedure header code with local store initialization and
	 *         creation of local object for parameters
	 * @throws JulietCodeGeneratorException
	 */
	public static JulietCode genProcedureBodyHeader(MBProcedure decl, boolean safe) throws DatabaseException {
		JulietCode resJulietCode = new JulietCode();
		Instruction ok = new Instruction(OpCodes.nop);

		OID[] args = decl.getArguments();
		if (!safe) {
			resJulietCode.emit(OpCodes.ldI, args.length);
			resJulietCode.emit(OpCodes.eqI);
			resJulietCode.emit(OpCodes.braTrue, ok);
			resJulietCode.emit(OpCodes.exception);
			resJulietCode.emit(ok);
		} else {
			resJulietCode.emit(OpCodes.pop);
		}
		// resJulietCode.emit(OpCodes.crLocS);
		resJulietCode.emit(OpCodes.modPush, decl.getModule().getOID().internalOID()); // TODO
																						// :
																						// to
																						// replace
																						// by
																						// replaced
		// by an ordinary oid

		// resJulietCode.emit(OpCodes.crLE); // TODO: check if new environment
		// frame for method parameters is taken off the ENVS
		if (args.length > 0) {
			/**
			 * generate meta-base procedure parameters opcodes
			 */

			resJulietCode.append(genInitProcedureParams(args, safe));
		}

		return resJulietCode;
	}

	/**
	 * @param julietCode
	 * @param julietCode2
	 * @return
	 */
	public static JulietCode genDynInsertExpression(JulietCode julietCode, JulietCode julietCode2) {
		assert false : "unimplemented";
		return new JulietCode();
	}

	/**
	 * Generates code for evaluating insert expression for rvalue cardinality =
	 * [1..1]
	 * 
	 * @return juliet code
	 */
	public static JulietCode genInsertExpression(JulietCode lvalueJtc, JulietCode rvalueJtc, boolean binderAsRvalue) {
		JulietCode resJt = new JulietCode(lvalueJtc);
		resJt.append(rvalueJtc);
		if (binderAsRvalue)
			return resJt.emit(OpCodes.moveNamed);
		else
			return resJt.emit(OpCodes.move);
	}

	/**
	 * Generates code for evaluating insert expression for rvalue cardinality <>
	 * [1..1]
	 * 
	 * @return juliet code
	 */
	public static JulietCode genColInsertExpression(JulietCode lvalueJtc, JulietCode rvalueJtc, boolean binderAsRvalue) {
		JulietCode resJt = new JulietCode();

		resJt.append(lvalueJtc);
		resJt.append(rvalueJtc);
		if (binderAsRvalue)
			resJt.emit(OpCodes.moveNamedCol);
		else
			resJt.emit(OpCodes.moveCol);
		return resJt.emit(OpCodes.fltn);
	}

	/**
	 * Generates code for evaluating virtual insert expression
	 * 
	 * @return juliet code
	 */
	public static JulietCode genVirtualInsert(JulietCode lvalueJtc, JulietCode rvalueJtc, int nameid) {
		JulietCode resJt = new JulietCode();

		resJt.append(lvalueJtc);
		resJt.append(rvalueJtc);
		// resJt.emit(OpCodes.dup);
		// resJt.append(JulietGen.createNestedEnvironment());
		// resJt.emit(OpCodes.swap);

		resJt.emit(OpCodes.virtMove, nameid);
		// resJt.append(JulietGen.destroyNestedEnvironment());
		return resJt;
	}

	// /////////////////////////Non-algebraic operators code
	// generation///////////////////////
	/**
	 * Generates Juliet code responsible for evaluation of non-algebraic binary
	 * operator dot
	 * 
	 * @param q1Jt
	 *            - Juliet code for left dot operand
	 * @param q2Jt
	 *            - Juliet code for right dot operand
	 * @return Juliet code evaluating dot expression
	 */
	public static JulietCode genDotExpression(JulietCode q1Jt, JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();

		JulietCode inLoop = new JulietCode();
		inLoop.append(createNestedEnvironment());
		inLoop.append(q2Jt);
		inLoop.append(destroyNestedEnvironment());
		inLoop.emit(OpCodes.insPrt2);

		resJt.emit(OpCodes.ldBag);
		resJt.append(q1Jt);
		resJt.append(JulietGen.genIterationWithCounter(inLoop));
		resJt.emit(OpCodes.fltn);
		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of non-algebraic binary
	 * operator join
	 * 
	 * @param q1Jt
	 *            - Juliet code for left join operand
	 * @param q2Jt
	 *            - Juliet code for right join operand
	 * @return Juliet code evaluating join expression
	 */
	public static JulietCode genJoinExpression(JulietCode q1Jt, JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();
		JulietCode inLoop = new JulietCode();

		inLoop.emit(OpCodes.dup);
		inLoop.append(createNestedEnvironment());
		inLoop.append(q2Jt);
		inLoop.append(destroyNestedEnvironment());
		inLoop.emit(OpCodes.crpd);
		inLoop.emit(OpCodes.insPrt2);

		resJt.emit(OpCodes.ldBag);
		resJt.append(q1Jt);
		resJt.append(JulietGen.genIterationWithCounter(inLoop));
		resJt.emit(OpCodes.fltn);
		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of non-algebraic binary
	 * operator where
	 * 
	 * @param q1Jt
	 *            - Juliet code for left where operand
	 * @param q2Jt
	 *            - Juliet code for right where operand
	 * @return Juliet code evaluating where expression
	 */
	public static JulietCode genWhereExpression(JulietCode q1Jt, JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();

		Instruction nincl = new Instruction(OpCodes.pop);
		Instruction incl = new Instruction(OpCodes.nop);
		JulietCode inLoop = new JulietCode();

		inLoop.emit(OpCodes.dup);
		inLoop.append(createNestedEnvironment());
		inLoop.append(q2Jt);
		inLoop.append(destroyNestedEnvironment());
		inLoop.emit(OpCodes.braFalse, nincl);
		inLoop.emit(OpCodes.insPrt2);
		inLoop.emit(OpCodes.bra, incl);
		inLoop.emit(nincl);
		inLoop.emit(incl);

		resJt.emit(OpCodes.ldBag);
		resJt.append(q1Jt);
		resJt.append(JulietGen.genIterationWithCounter(inLoop));
		resJt.emit(OpCodes.fltn);
		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of non-algebraic binary
	 * operator forsome
	 * 
	 * @param q1Jt
	 *            - Juliet code for left forsome operand
	 * @param q2Jt
	 *            - Juliet code for right forsome operand
	 * @return Juliet code evaluating for any expression
	 */
	public static JulietCode genForsomeExpression(JulietCode q1Jt, JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();

		Instruction loop = new Instruction(OpCodes.endCntr);
		Instruction end = new Instruction(OpCodes.swap);
		Instruction endFalse = new Instruction(OpCodes.ldFalse);

		resJt.append(q1Jt);
		resJt.append(JulietGen.createCounter());
		resJt.emit(loop);
		resJt.emit(OpCodes.braTrue, endFalse);
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.append(createNestedEnvironment());
		resJt.append(q2Jt);
		resJt.append(destroyNestedEnvironment());
		resJt.emit(OpCodes.incCntr);
		resJt.emit(OpCodes.braFalse, loop);
		resJt.emit(OpCodes.ldTrue);
		resJt.emit(OpCodes.bra, end);
		resJt.emit(endFalse);
		resJt.emit(end);
		resJt.emit(OpCodes.pop);
		resJt.append(JulietGen.destroyCounter());

		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of non-algebraic binary
	 * operator forall
	 * 
	 * @param q1Jt
	 *            - Juliet code for left forall operand
	 * @param q2Jt
	 *            - Juliet code for right forall operand
	 * @return (mereged) Juliet code evaluating for all expression
	 */
	public static JulietCode genForallExpression(JulietCode q1Jt, JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();

		Instruction loop = new Instruction(OpCodes.endCntr);
		Instruction end = new Instruction(OpCodes.swap);
		Instruction endTrue = new Instruction(OpCodes.ldTrue);

		resJt.append(q1Jt);
		resJt.append(JulietGen.createCounter());
		resJt.emit(loop);
		resJt.emit(OpCodes.braTrue, endTrue);
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.append(createNestedEnvironment());
		resJt.append(q2Jt);
		resJt.append(destroyNestedEnvironment());
		resJt.emit(OpCodes.incCntr);
		resJt.emit(OpCodes.braTrue, loop);
		resJt.emit(OpCodes.ldFalse);
		resJt.emit(OpCodes.bra, end);
		resJt.emit(endTrue);
		resJt.emit(end);
		resJt.emit(OpCodes.pop);
		resJt.append(JulietGen.destroyCounter());

		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of non-algebraic binary
	 * close by operator
	 * 
	 * @param q1Jt
	 *            - Juliet code for left close by operand
	 * @param q2Jt
	 *            - Juliet code for right close by operand
	 * @return Juliet code evaluating close by expression
	 */
	public static JulietCode genCloseByExpression(JulietCode q1Jt, JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();

		JulietCode inLoop = new JulietCode();
		JulietCode destroyCounter = JulietGen.destroyCounter();
		Instruction loop = new Instruction(OpCodes.endCntr);
		Instruction endloop = destroyCounter.getStart();

		inLoop.append(createNestedEnvironment());
		inLoop.append(q2Jt);
		inLoop.append(destroyNestedEnvironment());
		inLoop.emit(OpCodes.insPrt);
		inLoop.emit(OpCodes.dup);
		inLoop.emit(OpCodes.cnt);
		inLoop.emit(OpCodes.rbdCntr);

		resJt.emit(OpCodes.ldBag);
		resJt.append(q1Jt);
		resJt.emit(OpCodes.insPrt);
		resJt.append(JulietGen.createCounter());
		resJt.emit(loop);
		resJt.emit(OpCodes.braTrue, endloop);
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.append(inLoop);
		resJt.emit(OpCodes.incCntr);
		resJt.emit(OpCodes.bra, loop);
		resJt.append(destroyCounter);

		resJt.emit(OpCodes.fltn);
		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of non-algebraic binary
	 * close unique by operator
	 * 
	 * @param q1Jt
	 *            - Juliet code for left close unique by operand
	 * @param q2Jt
	 *            - Juliet code for right close unique by operand
	 * @return Juliet code evaluating close unique by expression
	 * @author root Tomasz Pieciukiewicz
	 */
	public static JulietCode genCloseUniqueByExpression(JulietCode q1Jt, JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();

		JulietCode destroyCounter = JulietGen.destroyCounter();
		Instruction loop = new Instruction(OpCodes.endCntr);

		resJt.emit(OpCodes.ldBag);
		resJt.append(q1Jt);
		resJt.emit(OpCodes.insPrt);
		resJt.append(JulietGen.createCounter());
		resJt.emit(loop);
		resJt.emit(OpCodes.braTrue, destroyCounter.getStart());
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.append(createNestedEnvironment());
		resJt.append(q2Jt);
		resJt.append(destroyNestedEnvironment());
		resJt.emit(OpCodes.insPrt);
		resJt.emit(OpCodes.unique);
		resJt.emit(OpCodes.dup);
		resJt.emit(OpCodes.cnt);
		resJt.emit(OpCodes.rbdCntr);
		resJt.emit(OpCodes.incCntr);
		resJt.emit(OpCodes.bra, loop);
		resJt.append(destroyCounter);
		resJt.emit(OpCodes.fltn);

		// resJt.append(JulietGen.genIterationWithCounter(inLoop));
		// resJt.emit(OpCodes.fltn);
		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of non-algebraic binary
	 * leaves by operator
	 * 
	 * @param q1Jt
	 *            - Juliet code for left leaves by operand
	 * @param q2Jt
	 *            - Juliet code for right leaves by operand
	 * @return Juliet code evaluating leaves by expression
	 * @author root Tomasz Pieciukiewicz
	 */
	public static JulietCode genLeavesByExpression(JulietCode q1Jt, JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();

		JulietCode destroyCounter = JulietGen.destroyCounter();
		Instruction loop = new Instruction(OpCodes.endCntr);
		Instruction notLeaf = new Instruction(OpCodes.insPrt);
		Instruction skok = new Instruction(OpCodes.dup);

		resJt.emit(OpCodes.ldBag);
		resJt.emit(OpCodes.ldBag);
		resJt.append(q1Jt);
		resJt.emit(OpCodes.insPrt);
		resJt.append(JulietGen.createCounter());
		resJt.emit(loop);
		resJt.emit(OpCodes.braTrue, destroyCounter.getStart());
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.append(createNestedEnvironment());
		resJt.append(q2Jt);
		resJt.append(destroyNestedEnvironment());
		resJt.emit(OpCodes.dup);
		resJt.emit(OpCodes.cnt);
		resJt.emit(OpCodes.ldI, 0);
		resJt.emit(OpCodes.eqI);
		resJt.emit(OpCodes.braFalse, notLeaf);
		resJt.emit(OpCodes.insPrt);
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.emit(OpCodes.insPrt2);
		resJt.emit(OpCodes.bra, skok);// tu si� ko�czy obs�uga li�cia
		resJt.emit(notLeaf);
		resJt.emit(skok);// skok po obs�udze li�cia
		resJt.emit(OpCodes.cnt);
		resJt.emit(OpCodes.rbdCntr);
		resJt.emit(OpCodes.incCntr);
		resJt.emit(OpCodes.bra, loop);
		resJt.append(destroyCounter);
		resJt.emit(OpCodes.pop);
		resJt.emit(OpCodes.fltn);

		// resJt.append(JulietGen.genIterationWithCounter(inLoop));
		// resJt.emit(OpCodes.fltn);
		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of non-algebraic binary
	 * leaves unique by operator
	 * 
	 * @param q1Jt
	 *            - Juliet code for left leaves unique by operand
	 * @param q2Jt
	 *            - Juliet code for right leaves unique by operand
	 * @return Juliet code evaluating leaves unique by expression
	 * @author root Tomasz Pieciukiewicz
	 */
	public static JulietCode genLeavesUniqueByExpression(JulietCode q1Jt, JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();

		JulietCode destroyCounter = JulietGen.destroyCounter();
		Instruction loop = new Instruction(OpCodes.endCntr);
		Instruction notLeaf = new Instruction(OpCodes.insPrt);
		Instruction skok = new Instruction(OpCodes.unique);

		resJt.emit(OpCodes.ldBag);
		resJt.emit(OpCodes.ldBag);
		resJt.append(q1Jt);
		resJt.emit(OpCodes.insPrt);
		resJt.emit(OpCodes.dup);
		resJt.emit(OpCodes.cnt);
		resJt.append(JulietGen.createCounter());
		resJt.emit(loop);
		resJt.emit(OpCodes.braTrue, destroyCounter.getStart());
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.append(createNestedEnvironment());
		resJt.append(q2Jt);
		resJt.append(destroyNestedEnvironment());
		resJt.emit(OpCodes.dup);
		resJt.emit(OpCodes.cnt);
		resJt.emit(OpCodes.ldI, 0);
		resJt.emit(OpCodes.eqI);
		resJt.emit(OpCodes.braFalse, notLeaf);
		resJt.emit(OpCodes.insPrt);
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.emit(OpCodes.insPrt2);
		resJt.emit(OpCodes.bra, skok);// tu si� ko�czy obs�uga li�cia
		resJt.emit(notLeaf);
		resJt.emit(skok);// skok po obs�udze li�cia
		resJt.emit(OpCodes.dup);
		resJt.emit(OpCodes.cnt);
		resJt.emit(OpCodes.rbdCntr);
		resJt.emit(OpCodes.incCntr);
		resJt.emit(OpCodes.bra, loop);
		resJt.append(destroyCounter);
		resJt.emit(OpCodes.pop);
		resJt.emit(OpCodes.fltn);

		// resJt.append(JulietGen.genIterationWithCounter(inLoop));
		// resJt.emit(OpCodes.fltn);
		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of non-algebraic binary
	 * operator order by 'q1 order by q2'
	 * 
	 * @param q1Jt
	 *            - Juliet code for left order by operand
	 * @param q2Jt
	 *            - Juliet code for right order by operand
	 * @return (mereged) Juliet code evaluating order by expression
	 */
	public static JulietCode genOrderByExpression(JulietCode q1Jt, JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();
		JulietCode inLoop = new JulietCode();

		inLoop.emit(OpCodes.dup);
		inLoop.append(createNestedEnvironment());
		// for the crpd operator we leave named result on the qres to avoid
		// struct flattering (the name itself does not matter)
		inLoop.emit(OpCodes.grAs, odra.system.Names.VALUE_ID);
		inLoop.append(q2Jt);
		inLoop.append(destroyNestedEnvironment());
		inLoop.emit(OpCodes.crpd);
		inLoop.emit(OpCodes.insPrt2);

		resJt.emit(OpCodes.ldBag);
		resJt.append(q1Jt);
		resJt.append(JulietGen.genIterationWithCounter(inLoop));
		resJt.emit(OpCodes.orby);
		resJt.emit(OpCodes.fltn);
		return resJt;

	}

	////////////////////////////////////////////////////////////////////////////
	// //////////
	// ///////////////loop expressions code
	// generation/////////////////////////////

	/**
	 * Generates Juliet code responsible for evaluation of loop 'non-algebraic
	 * like' binary operator foreach
	 * 
	 * @param q1Jt
	 *            - Juliet code for foreach operand (expression)
	 * @param q2Jt
	 *            - Juliet code for foreach do statement
	 * @return (mereged) Juliet code evaluating for each expression
	 */
	public static JulietCode genForeachExpression(JulietCode exprJt, JulietCode stmtJt) {
		// TODO there is a problem with the stack when return appears inside the
		// foreach block
		// the result stack is inconsistent because the counter iterates over
		// the result on the QRES that is not popped
		Instruction incrementCounter = new Instruction(OpCodes.incCntr);
		Instruction loop = new Instruction(OpCodes.endCntr);
		JulietCode destroyCounter = JulietGen.destroyCounter();

		JulietCode resJt = new JulietCode();
		JulietCode destroyNested = destroyNestedEnvironment();

		JulietCode breakCode = new JulietCode();
		breakCode.append(destroyNestedEnvironment());

		stmtJt.fixReturn(new JulietCode().emit(OpCodes.pop));
		boolean wasPatched = stmtJt.backPatch(breakCode.getStart(), destroyNested.getStart());

		resJt.append(exprJt);
		resJt.append(JulietGen.createCounter());
		resJt.emit(loop);
		resJt.emit(OpCodes.braTrue, destroyCounter.getStart());
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.append(createNestedEnvironment());
		resJt.append(stmtJt);
		resJt.append(destroyNested);
		resJt.emit(incrementCounter);
		resJt.emit(OpCodes.bra, loop);
		if (wasPatched) {
			resJt.append(breakCode);
		}
		resJt.append(destroyCounter);
		resJt.emit(OpCodes.pop);

		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of while loop operator
	 * 
	 * @param condJt
	 *            - the code for condition - result is boolean value
	 * @param stmtJt
	 *            - the statememt code to execute inside loop
	 * @return (mereged) Juliet code evaluating while expression
	 */
	public static JulietCode genWhileLoop(JulietCode condJt, JulietCode stmtJt) {

		/**
		 * JulietCode for: while cond do stm
		 * 
		 * 1: cond [false goto 2] stm goto 1 2: nop
		 */
		Instruction end = new Instruction(OpCodes.nop);

		Instruction loop = condJt.getStart();

		stmtJt.backPatch(end, loop);

		JulietCode resJt = new JulietCode(condJt);
		resJt.emit(OpCodes.braFalse, end);
		resJt.append(stmtJt);
		resJt.emit(OpCodes.bra, condJt.getStart());

		resJt.emit(end);
		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of do-while loop
	 * operator
	 * 
	 * @param condJt
	 *            - the code for condition - result is boolean value
	 * @param stmtJt
	 *            - the statememt code to execute inside loop
	 * @return (mereged) Juliet code
	 */
	public static JulietCode genDoWhileLoop(JulietCode condJt, JulietCode stmtJt) {

		/**
		 * JulietCode for: do stm while cond
		 * 
		 * 1: stm cond [true goto 1]
		 * 
		 * 
		 */
		Instruction end = new Instruction(OpCodes.nop);

		// patch breaks and continues (if required)
		stmtJt.backPatch(end, condJt.getStart());
		JulietCode resJt = new JulietCode(stmtJt);
		resJt.append(condJt);
		resJt.emit(OpCodes.braTrue, stmtJt.getStart());
		resJt.emit(OpCodes.bra, end);

		resJt.emit(end);
		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of 'for' loop
	 * 
	 * @param initJt
	 *            - initialization code for loop counter
	 * @param condJt
	 *            - condition code to be evaluated each time
	 * @param incrJt
	 *            - code for incrementing the counter
	 * @param stmtJt
	 *            - the statememt code to execute inside loop
	 * @return
	 */
	public static JulietCode genForLoop(JulietCode initJt, JulietCode condJt, JulietCode incrJt, JulietCode stmtJt) {
		/**
		 * JulietCode for: for (init; cond; incr) stm
		 * 
		 * init 1: cond [ false goto 2] stm incr goto 1 2: nop
		 */
		if (!isNop(initJt)) {
			// init expression result must be popped
			initJt.emit(OpCodes.pop);
		}
		if (!isNop(incrJt)) {
			// increment expression result must be popped
			incrJt.emit(OpCodes.pop);
		}
		if (isNop(condJt)) {
			condJt = JulietGen.genBooleanExpression(true);
		}
		Instruction end = new Instruction(OpCodes.nop);

		stmtJt.backPatch(end, incrJt.getStart());

		JulietCode resJt = new JulietCode(initJt);
		resJt.append(condJt);
		resJt.emit(OpCodes.braFalse, end);
		resJt.append(stmtJt);
		resJt.append(incrJt);
		resJt.emit(OpCodes.bra, condJt.getStart());

		resJt.emit(end);
		return resJt;
	}

	/**
	 * @param jtCode
	 * @return true if code contains only nop opcode
	 */
	private static boolean isNop(JulietCode jtCode) {
		return ((jtCode.size() == 1) && (jtCode.getStart().getOpcode().equals(OpCodes.nop)));
	}

	////////////////////////////////////////////////////////////////////////////
	// //////////
	// /////////////////conditional expresions code
	// generation/////////////////////////////
	/**
	 * Generates Juliet code responsible for evaluation of if-then-else
	 * expression
	 * 
	 * @param condJt
	 *            - the code for condition - result is boolean value
	 * @param thenJt
	 *            - the code to execute when condition is true
	 * @param elseJt
	 *            - the code to execute when condition is false
	 * @return merged Juliet code
	 */
	public static JulietCode genConditionalExpression(JulietCode condJt, JulietCode thenJt, JulietCode elseJt) {
		JulietCode resJt = new JulietCode(condJt);
		Instruction end = new Instruction(OpCodes.nop);

		resJt.emit(OpCodes.braTrue, thenJt.getStart());
		resJt.append(elseJt);
		resJt.emit(OpCodes.bra, end);
		resJt.append(thenJt);
		resJt.emit(end);
		return resJt;
	}

	public static JulietCode genIfThenElseStatement(JulietCode condJt, JulietCode thenJt, JulietCode elseJt) {
		return genConditionalExpression(condJt, thenJt, elseJt);
	}

	////////////////////////////////////////////////////////////////////////////
	// //////////
	// /////////////////conditional expresions code
	// generation/////////////////////////////
	/**
	 * Generates Juliet code responsible for evaluation of if expression
	 * 
	 * @param condJt
	 *            - the code for condition - result is boolean value
	 * @param thenJt
	 *            - the code to execute when condition is true
	 * 
	 * @return merged Juliet code
	 */
	public static JulietCode genIfThenStatement(JulietCode condJt, JulietCode thenJt) {
		JulietCode resJt = new JulietCode(condJt);
		Instruction end = new Instruction(OpCodes.nop);
		resJt.emit(OpCodes.braFalse, end);
		resJt.append(thenJt);
		resJt.emit(end);
		return resJt;
	}

	////////////////////////////////////////////////////////////////////////////
	// //////////
	// /////////////////////binary expression code
	// generation/////////////////////////////
	/**
	 * Generates Juliet code responsible for evaluation of simple binary
	 * expression
	 * 
	 * @param ilq1
	 *            - left operand
	 * @param ilq2
	 *            - right operand
	 * @param OpCode
	 *            - proper binary opcode (e.g. eqS, grI, etc.)
	 * @return merged Juliet code
	 */
	public final static JulietCode genSimpleBinaryExpression(JulietCode q1Jt, JulietCode q2Jt, OpCodes opJt) {
		if (opJt == OpCodes.and)
			return JulietGen.genLogicalAndExpression(q1Jt, q2Jt);

		return new JulietCode(q1Jt).append(q2Jt).emit(opJt);
	}

	/**
	 * Generates Juliet code responsible for evaluation of logical and
	 * expression if the first operand returns false the second operand is not
	 * evaluated
	 * 
	 * @param ilq1
	 *            - left operand
	 * @param ilq2
	 *            - right operand
	 * @param OpCode
	 *            - proper binary opcode (e.g. eqS, grI, etc.)
	 * @return merged Juliet code
	 */
	public final static JulietCode genLogicalAndExpression(JulietCode q1Jt, JulietCode q2Jt) {
		Instruction end = new Instruction(OpCodes.nop);
		JulietCode resJt = new JulietCode(q1Jt);
		resJt.emit(OpCodes.dup);
		resJt.emit(OpCodes.braFalse, end);
		resJt.append(q2Jt);
		resJt.emit(OpCodes.and);
		resJt.emit(end);

		return resJt;
	}

	/**
	 * Generates Juliet code responsible for evaluation of simple binary
	 * expression with dynamic runtime typecheking
	 * 
	 * @param ilq1
	 *            - left operand
	 * @param ilq2
	 *            - right operand
	 * @param OpCode
	 *            - opcode form parser (we used it in case of no type
	 *            information avaliable)
	 * @return merged Juliet code
	 */
	public final static JulietCode genDynSimpleBinaryExpression(JulietCode q1Jt, JulietCode q2Jt, int opcode) {
		// JulietCode jtCode = new JulietCode();
		// jtCode.append(q1Jt).append(JulietGen.genDynDeref());
		// jtCode.append(q2Jt).append(JulietGen.genDynDeref());

		JulietCode jtCode = new JulietCode(JulietGen.genDynDeref(q1Jt));

		OpCodes opcJt = OpCodes.nop;
		switch (opcode) {
		case Operator.PLUS:
			opcJt = OpCodes.dynAdd;
			break;
		case Operator.MINUS:
			opcJt = OpCodes.dynSub;
			break;
		case Operator.MULTIPLY:
			opcJt = OpCodes.dynMul;
			break;
		case Operator.DIVIDE:
			opcJt = OpCodes.dynDiv;
			break;
		case Operator.MODULO:
			opcJt = OpCodes.dynRem;
			break;
		case Operator.GREATER:
			opcJt = OpCodes.dynGr;
			break;
		case Operator.LOWER:
			opcJt = OpCodes.dynLo;
			break;
		case Operator.GREATEREQUALS:
			opcJt = OpCodes.dynGrEq;
			break;
		case Operator.LOWEREQUALS:
			opcJt = OpCodes.dynLoEq;
			break;
		case Operator.OR:
			opcJt = OpCodes.dynOr;
			break;
		case Operator.AND:
			return JulietGen.genLogicalAndExpression(jtCode, JulietGen.genDynDeref(q2Jt));

		case Operator.DIFFERENT:
			opcJt = OpCodes.dynNEq;
			break;
		case Operator.EQUALS:
			opcJt = OpCodes.dynEq;
			break;
		case Operator.MATCH_STRING:
			opcJt = OpCodes.matchString;
			break;
		case Operator.NOT_MATCH_STRING:
			opcJt = OpCodes.notMatchString;
			break;
		default:
			assert false : "generator: unknown binary opcode " + Operator.get(opcode).spell();
			break;
		}
		jtCode.append(JulietGen.genDynDeref(q2Jt));
		return jtCode.emit(opcJt);
	}

	/**
	 * Generates Juliet code responsible for evaluation of
	 * 
	 * @param ilq1
	 *            - left operand
	 * @param ilq2
	 *            - right operand
	 * 
	 * @return merged Juliet code
	 */
	public final static JulietCode genAssignExpression(JulietCode q1Jt, JulietCode q2Jt, JulietCode assignJt) {
		return new JulietCode(q2Jt).append(q1Jt).append(assignJt);
	}

	public final static JulietCode genAssignReverseReference(int revnameid) {
		JulietCode jtExpr = new JulietCode();

		jtExpr.emit(OpCodes.dup);
		jtExpr.emit(OpCodes.reflParent);
		jtExpr.emit(OpCodes.swap);
		jtExpr.emit(OpCodes.bswap2);
		jtExpr.emit(OpCodes.dup_x1);
		jtExpr.emit(OpCodes.swap);
		jtExpr.emit(OpCodes.storeRef);
		jtExpr.emit(OpCodes.swap);
		jtExpr.emit(OpCodes.bswap2);
		jtExpr.emit(OpCodes.swap);
		jtExpr.emit(OpCodes.crRef, revnameid);
		// reverse agg??
		jtExpr.emit(OpCodes.storeRef);
		jtExpr.emit(OpCodes.swap);
		jtExpr.emit(OpCodes.dup_x1);
		jtExpr.emit(OpCodes.storeRevRef);
		return jtExpr;
	}

	/**
	 * Generates Juliet code responsible for evaluation of assign expression
	 * with dynamic runtime typecheking
	 * 
	 * @param lqJt
	 *            - left operand
	 * @param rqJt
	 *            - right operand
	 * 
	 * @return merged Juliet code
	 */
	public final static JulietCode genDynAssignExpression(JulietCode lqJt, JulietCode rqJt) {
		// Instruction end = new Instruction(OpCodes.nop);
		// JulietCode virtUpd = JulietGen.genAssignVirtual();
		JulietCode jtExpr = new JulietCode();
		jtExpr.append(JulietGen.genDynDeref(rqJt));
		jtExpr.append(lqJt);
		// jtExpr.emit(OpCodes.dup);
		// jtExpr.emit(OpCodes.ifVirt, virtUpd.getStart());
		jtExpr.emit(OpCodes.dynStore);
		// jtExpr.emit(OpCodes.bra, end);
		// jtExpr.append(virtUpd);
		// jtExpr.emit(end);

		return jtExpr;
	}

	/**
	 * Generates Juliet code responsible for evaluation of assign expression
	 * with dynamic runtime typecheking
	 * 
	 * @param lqJt
	 *            - left operand
	 * @param rqJt
	 *            - right operand
	 * 
	 * @return merged Juliet code
	 */
	public final static JulietCode genVirtualAssignExpression(JulietCode lqJt, JulietCode rqJt) {

		JulietCode jtExpr = new JulietCode();
		jtExpr.append(rqJt);
		jtExpr.append(lqJt);
		jtExpr.emit(OpCodes.dynStore);

		return jtExpr;
	}

	////////////////////////////////////////////////////////////////////////////
	// //////////

	// ///////////////////literals, names binding code
	// generation///////////////////////////////
	/**
	 * Generates Juliet code responsible for evaluation of constant boolean
	 * expression
	 * 
	 * @param value
	 *            - true or false
	 * @return Juliet code for loading boolean literal
	 */
	public static JulietCode genBooleanExpression(boolean value) {
		Instruction i;
		if (value)
			return new JulietCode().emit(OpCodes.ldTrue);
		return new JulietCode().emit(OpCodes.ldFalse);
	}

	/**
	 * Generates Juliet code responsible for evaluation of constant integer
	 * expression
	 * 
	 * @param value
	 *            - constant integer value
	 * @return Juliet code for loading integer literal
	 */
	public final static JulietCode genIntegerExpression(int value) {

		return new JulietCode().emit(OpCodes.ldI, value);
	}

	/**
	 * Generates Juliet code responsible for evaluation of constant real
	 * expression
	 * 
	 * @param id
	 *            - constant pool index
	 * @return Juliet code for loading integer literal
	 */
	public final static JulietCode genRealExpression(int id) {
		return new JulietCode().emit(OpCodes.ldcR, id);
	}

	/**
	 * Generates Juliet code responsible for evaluation of constant string
	 * expression
	 * 
	 * @param id
	 *            - constant pool index
	 * @return Juliet code for loading string literal
	 */
	public final static JulietCode genStringExpression(int id) {
		return new JulietCode().emit(OpCodes.ldcS, id);
	}

	/**
	 * Generates Juliet code responsible for evaluation of constant date
	 * expression
	 * 
	 * @param id
	 *            - constant pool index
	 * @return Juliet code for loading date literal
	 */
	public final static JulietCode genDateExpression(int id) {
		return new JulietCode().emit(OpCodes.ldcD, id);
	}

	/**
	 * Generates Juliet code responsible for evaluation of name expression
	 * 
	 * @param id
	 *            - index of the name in the name index
	 * @return Juliet code for binding name
	 */
	public final static JulietCode genNameExpression(int id) {
		return new JulietCode().emit(OpCodes.bind, id);
	}

	/**
	 * Generates Juliet code responsible for evaluation of name expression
	 * (dynamic version)
	 * 
	 * @param id
	 *            - index of the name in the name index
	 * @return Juliet code for binding name
	 */
	public final static JulietCode genDynNameExpression(int id) {
		JulietCode resJt = new JulietCode();
		Instruction end = new Instruction(OpCodes.nop);

		resJt.emit(OpCodes.bind, id);
		resJt.emit(OpCodes.dup);
		resJt.emit(OpCodes.ifnSack, end);
		resJt.append(JulietGen.genDynCallVirtualObjects());
		resJt.emit(end);
		return resJt;
	}

	// /////////////////////////////////////////////////////////////////
	// //unary expressions///////////////////////////////////////////

	/**
	 * Generates Juliet code responsible for evaluation of simple unary
	 * exression
	 * 
	 * @param jexpr
	 *            - code the unary operators work on
	 * @param opcode
	 *            - unary operator opcode
	 * @return Juliet code for unary expression
	 */
	public final static JulietCode genSimpleUnaryExpression(JulietCode jexpr, OpCodes opcode) {
		return new JulietCode(jexpr).emit(opcode);
	}

	/**
	 * Generates Juliet code responsible for evaluation of simple unary
	 * expression with dynamic runtime typecheking
	 * 
	 * @param ilq1
	 *            - left operand
	 * @param ilq2
	 *            - right operand
	 * @param OpCode
	 *            - opcode form parser (we used it in case of no type
	 *            information avaliable)
	 * @return merged Juliet code
	 */
	public final static JulietCode genDynSimpleUnaryExpression(JulietCode qJt, int opcode) {
		JulietCode jtCode = new JulietCode(JulietGen.genDynDeref(qJt));
		// JulietCode jtCode = new JulietCode();
		// jtCode.append(qJt).append(JulietGen.genDynDeref());

		OpCodes opcJt;

		switch (opcode) {
		case Operator.MINUS:
			opcJt = OpCodes.dynNeg;
			break;
		case Operator.NOT:
			opcJt = OpCodes.dynNot;
			break;
		default:
			assert false : "generator: unknown unary opcode";
			opcJt = OpCodes.nop;
			break;
		}
		return jtCode.emit(opcJt);
	}

	/**
	 * Juliet code responsible for evaluation of as expression (operator assumes
	 * that jexpr returns collection)
	 * 
	 * @param jexpr
	 *            - Juliet code the dynAs operator works on
	 * @param nameid
	 *            - name index value for the as operator name parameter
	 * @return Juliet code for as expression (dynamic - i.e. operator assumes
	 *         that jexpr returns collection)
	 */
	public final static JulietCode genColAsExpression(JulietCode jexpr, int nameid) {
		return new JulietCode(jexpr).emit(OpCodes.colAs, nameid).emit(OpCodes.fltn);

	}

	/**
	 * Generates Juliet code responsible for evaluation of as expression
	 * 
	 * @param jexpr
	 *            - Juliet code the 'as' operator works on
	 * @param nameid
	 *            - name index value for the as operator name parameter
	 * @return Juliet code for as expression
	 */
	public final static JulietCode genAsExpression(JulietCode jexpr, int nameid) {
		return new JulietCode(jexpr).emit(OpCodes.as, nameid);

	}

	/**
	 * Generates Juliet code responsible for evaluation of group as expression
	 * 
	 * @param jexpr
	 *            - Juliet code the 'group as' operator works on
	 * @param nameid
	 *            - name index value for the 'group as' operator name parameter
	 * @return Juliet code for group as expression
	 */
	public final static JulietCode genGroupAsExpression(JulietCode jexpr, int nameid) {
		return new JulietCode(jexpr).emit(OpCodes.grAs, nameid);

	}

	/**
	 * Generates Juliet code responsible for evaluation ref expression
	 * 
	 * @return Juliet code for ref expression
	 */
	public final static JulietCode genRefExpression() {
		return new JulietCode().emit(OpCodes.ref);

	}

	/**
	 * Generates Juliet code responsible for evaluation ref expression
	 * 
	 * @return Juliet code for ref expression
	 */
	public final static JulietCode genColRefExpression() {
		return new JulietCode().emit(OpCodes.colRef).emit(OpCodes.fltn);

	}

	/**
	 * Generates Juliet code responsible for evaluation ref expression in
	 * dynamic version (with runtime typecheck)
	 * 
	 * @return Juliet code for ref expression
	 */
	public final static JulietCode genDynRefExpression() {
		return new JulietCode().emit(OpCodes.dynRef).emit(OpCodes.fltn);

	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of
	 * integer object
	 * 
	 * @return Juliet code for dereference of integer object
	 */
	public final static JulietCode genDerefIntExpression() {
		return genDerefExpression(OpCodes.derefI);

	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of
	 * integer objects ( assumes that the operand is a collection)
	 * 
	 * @return Juliet code for dereference of collection of integer objects
	 */
	public final static JulietCode genDerefColIntExpression() {
		return genColDerefExpression(OpCodes.derefColI);

	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of real
	 * object
	 * 
	 * @return Juliet code for dereference of real object
	 */
	public final static JulietCode genDerefRealExpression() {
		return genDerefExpression(OpCodes.derefR);

	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of real
	 * objects ( assumes that the operand is a collection)
	 * 
	 * @return Juliet code for dereference of collection of real objects
	 */
	public final static JulietCode genDerefColRealExpression() {
		return genColDerefExpression(OpCodes.derefColR);

	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of date
	 * object
	 * 
	 * @return Juliet code for dereference of date object
	 */
	public final static JulietCode genDerefDateExpression() {
		return genDerefExpression(OpCodes.derefD);
	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of date
	 * objects ( assumes that the operand is a collection)
	 * 
	 * @return Juliet code for dereference of collection of date objects
	 */
	public final static JulietCode genDerefColDateExpression() {
		return genColDerefExpression(OpCodes.derefColD);

	}

	/**
	 * Generates Juliet code responsible for evaluation of boolean object
	 * 
	 * @return Juliet code for dereference of boolean object
	 */
	public final static JulietCode genDerefBooleanExpression() {
		return genDerefExpression(OpCodes.derefB);

	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of
	 * boolean objects ( assumes that the operand is a collection)
	 * 
	 * @return Juliet code for dereference of collection of boolean objects
	 */
	public final static JulietCode genDerefColBooleanExpression() {
		return genColDerefExpression(OpCodes.derefColB);

	}

	/**
	 * Generates Juliet code responsible for evaluation of string object
	 * 
	 * @return Juliet code for dereference of string object
	 */
	public final static JulietCode genDerefStringExpression() {
		return genDerefExpression(OpCodes.derefS);

	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of string
	 * objects ( assumes that the operand is a collection)
	 * 
	 * @return Juliet code for dereference of collection of string objects
	 */
	public final static JulietCode genDerefColStringExpression() {
		return genColDerefExpression(OpCodes.derefColS);

	}

	/**
	 * Generates Juliet code responsible for evaluation of reference object
	 * 
	 * @return Juliet code for dereference of reference object
	 */
	public final static JulietCode genDerefRefExpression() {
		return genDerefExpression(OpCodes.derefRef);

	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of
	 * reference objects ( assumes that the operand is a collection)
	 * 
	 * @return Juliet code for dereference of collection of reference objects
	 */
	public final static JulietCode genDerefColRefExpression() {
		return genColDerefExpression(OpCodes.derefColRef);

	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of
	 * complex object
	 * 
	 * @return Juliet code for dereference of complex object
	 */
	public final static JulietCode genDerefComplexExpression() {
		return genDerefExpression(OpCodes.derefCpx);

	}

	/**
	 * Generates Juliet code responsible for evaluation of dereference of
	 * complex objects ( assumes that the operand is a collection)
	 * 
	 * @return Juliet code for dereference of collection of complex objects
	 */
	public final static JulietCode genDerefColComplexExpression() {
		return genColDerefExpression(OpCodes.derefColCpx);

	}

	public final static JulietCode genDynDeref(JulietCode operandCode) {
		if (operandCode.getEnd().isConstant()) {
			return operandCode;
		}
		JulietCode resJt = new JulietCode(operandCode);
		JulietCode inLoop = new JulietCode();
		inLoop.emit(OpCodes.dynDeref).emit(OpCodes.insPrt2);

		resJt.emit(OpCodes.ldBag);
		resJt.emit(OpCodes.swap);

		resJt.append(JulietGen.genIterationWithCounter(inLoop));
		resJt.emit(OpCodes.fltn);
		return resJt;

	}

	// /////////////////////////////////////////////////////////////////

	/**
	 * Generates Juliet code responsible for evaluation of exist expression
	 * 
	 * @return Juliet code for exist expression
	 */
	public final static JulietCode genExistExpression(JulietCode jexpr) {
		return new JulietCode(jexpr).emit(OpCodes.exist);

	}

	////////////////////////////////////////////////////////////////////////////
	// //////
	// ////////////////////////collection
	// expressions/////////////////////////////////

	/**
	 * Generates Juliet code responsible for evaluation of count expression
	 * 
	 * @param jexpr
	 *            - Juliet code for count operand
	 * @return Juliet code for count expression
	 */
	public final static JulietCode genCountExpression(JulietCode jexpr) {
		return new JulietCode(jexpr).emit(OpCodes.cnt);

	}

	public final static JulietCode genDynSumExpression(JulietCode jexpr) {
		JulietCode resJt = new JulietCode(JulietGen.genDynDeref(jexpr));

		return JulietGen.genSumExpression(resJt, -1);

	}

	public final static JulietCode genSumIntExpression(JulietCode jexpr) {

		return JulietGen.genSumExpression(jexpr, 0);

	}

	public final static JulietCode genSumRealExpression(JulietCode jexpr) {

		return JulietGen.genSumExpression(jexpr, 1);

	}

	/**
	 * Generates Juliet code responsible for evaluation of sum expression
	 * 
	 * @param jexpr
	 *            - Juliet code for sum operand
	 * @param type
	 *            - 0 - sum int, 1 - sum double, other - dynamic sum
	 * @return Juliet code for sum expression
	 */
	private final static JulietCode genSumExpression(JulietCode jexpr, int type) {
		Instruction loop = new Instruction(OpCodes.endCntr);
		Instruction end = new Instruction(OpCodes.pop);
		// jexpr.emit(OpCodes.nonEmpty);
		if (type == 1)
			jexpr.emit(OpCodes.ldcR_0);
		else
			jexpr.emit(OpCodes.ldI, 0);
		jexpr.emit(OpCodes.swap);
		jexpr.append(JulietGen.createCounter());
		jexpr.emit(loop);
		jexpr.emit(OpCodes.braTrue, end);
		jexpr.emit(OpCodes.ldCntr);
		jexpr.emit(OpCodes.extr);
		jexpr.emit(OpCodes.bswap2);
		switch (type) {
		case 0:
			jexpr.emit(OpCodes.addI);
			break;
		case 1:
			jexpr.emit(OpCodes.addR);
			break;
		default:
			jexpr.emit(OpCodes.dynAdd);
			break;

		}
		jexpr.emit(OpCodes.swap);
		jexpr.emit(OpCodes.incCntr);
		jexpr.emit(OpCodes.bra, loop);
		jexpr.emit(end);
		jexpr.append(JulietGen.destroyCounter());

		return jexpr;

	}

	public final static JulietCode genDynMaxExpression(JulietCode jexpr) {
		JulietCode resJt = JulietGen.genDynDeref(jexpr);
		return JulietGen.genMaxExpression(resJt);

	}

	/**
	 * Generates Juliet code responsible for evaluation of max expression
	 * 
	 * @param jexpr
	 *            - Juliet code for max operand
	 * @param type
	 *            - 0 - max int, 1 - maxdouble, other - dynamic (with runtime
	 *            typecheck) max
	 * @return Juliet code for max expression
	 */
	public final static JulietCode genMaxExpression(JulietCode jexpr) {
		JulietCode resJt = new JulietCode(jexpr);
		resJt.emit(OpCodes.nonEmpty);
		return resJt.emit(OpCodes.max);
	}

	public final static JulietCode genDynMinExpression(JulietCode jexpr) {
		JulietCode resJt = new JulietCode(JulietGen.genDynDeref(jexpr));

		return JulietGen.genMinExpression(resJt);

	}

	/**
	 * Generates Juliet code responsible for evaluation of min expression
	 * 
	 * @param jexpr
	 *            - Juliet code for min operand
	 * @return Juliet code for min expression
	 */
	public final static JulietCode genMinExpression(JulietCode jexpr) {
		JulietCode resJt = new JulietCode(jexpr);
		resJt.emit(OpCodes.nonEmpty);
		return resJt.emit(OpCodes.min);
	}

	/**
	 * Generates Juliet code responsible for evaluation of cartesian product
	 * expression
	 * 
	 * @param jexprl
	 *            - left operand
	 * @param jexprr
	 *            - right operand
	 * @return Juliet code for cartesian product expression
	 */
	public final static JulietCode genCartesianProductExpression(JulietCode jexprl, JulietCode jexprr) {
		return new JulietCode(jexprl).append(jexprr).emit(OpCodes.crpd).emit(OpCodes.fltn);
	}

	/**
	 * Generates Juliet code responsible for evaluation of union expression
	 * 
	 * @param jexprl
	 *            - left operand
	 * @param jexprr
	 *            - right operand
	 * @return Juliet code for union expression
	 */
	public final static JulietCode genUnionExpression(JulietCode jexprl, JulietCode jexprr) {
		return new JulietCode(jexprl).append(jexprr).emit(OpCodes.union).emit(OpCodes.fltn);
	}

	/**
	 * Generates Juliet code responsible for evaluation of union expression
	 * (alternative version without specific opcode)
	 * 
	 * @param jexprl
	 *            - left operand
	 * @param jexprr
	 *            - right operand
	 * @return Juliet code for union expression
	 */
	public final static JulietCode genUnion1Expression(JulietCode jexprl, JulietCode jexprr) {
		JulietCode resJt = new JulietCode();
		Instruction loop1 = new Instruction(OpCodes.endCntr);
		Instruction loop2 = new Instruction(OpCodes.endCntr);
		Instruction end1 = new Instruction(OpCodes.pop);
		Instruction end2 = new Instruction(OpCodes.pop);

		resJt.append(jexprl);
		resJt.emit(OpCodes.ldBag);
		resJt.emit(OpCodes.swap);
		resJt.append(JulietGen.createCounter());
		resJt.emit(loop1);
		resJt.emit(OpCodes.braTrue, end1);
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.emit(OpCodes.insPrt2);
		resJt.emit(OpCodes.incCntr);
		resJt.emit(OpCodes.bra, loop1);
		resJt.emit(end1);
		resJt.append(jexprr);
		resJt.append(JulietGen.createCounter());
		resJt.emit(loop2);
		resJt.emit(OpCodes.braTrue, end2);
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.emit(OpCodes.insPrt2);
		resJt.emit(OpCodes.incCntr);
		resJt.emit(OpCodes.bra, loop2);
		resJt.emit(end2);

		return resJt.emit(OpCodes.fltn);
	}

	/**
	 * Generates Juliet code responsible for evaluation of in expression
	 * 
	 * @param jexprl
	 *            - left operand
	 * @param jexprr
	 *            - right operand
	 * @return Juliet code for in expression
	 */
	public final static JulietCode genInExpression(JulietCode jexprl, JulietCode jexprr) {
		JulietCode resJt = new JulietCode();
		resJt.append(jexprl);
		resJt.append(jexprr);
		return resJt.emit(OpCodes.in);
	}

	public final static JulietCode genDynInExpression(JulietCode jexprl, JulietCode jexprr) {
		JulietCode resJtl = new JulietCode(JulietGen.genDynDeref(jexprl));
		JulietCode resJtr = new JulietCode(JulietGen.genDynDeref(jexprr));
		return JulietGen.genInExpression(resJtl, resJtr);
	}

	/**
	 * Generates Juliet code responsible for evaluation of intersect expression
	 * 
	 * @param jexprl
	 *            - left operand
	 * @param jexprr
	 *            - right operand
	 * @return Juliet code for intersect expression
	 */
	public final static JulietCode genIntersectExpression(JulietCode jexprl, JulietCode jexprr) {
		JulietCode resJt = new JulietCode();

		resJt.append(jexprl);
		resJt.append(jexprr);
		resJt.emit(OpCodes.intersect);
		return resJt.emit(OpCodes.fltn);

	}

	/**
	 * Generates Juliet code responsible for evaluation of set difference
	 * expression
	 * 
	 * @param jexprl
	 *            - left operand
	 * @param jexprr
	 *            - right operand
	 * @return Juliet code for set difference expression
	 */
	public final static JulietCode genDifferenceExpression(JulietCode jexprl, JulietCode jexprr) {
		JulietCode resJt = new JulietCode();

		resJt.append(jexprl);
		resJt.append(jexprr);
		resJt.emit(OpCodes.diff);
		return resJt.emit(OpCodes.fltn);

	}

	/**
	 * Generates Juliet code responsible for evaluation of unique expression
	 * 
	 * @param jexpr
	 *            - Juliet code for unique operand
	 * @return Juliet code for unique expression
	 */
	public final static JulietCode genUniqueExpression(JulietCode jexpr) {
		JulietCode resJt = new JulietCode();
		resJt.append(jexpr);
		return resJt.emit(OpCodes.unique).emit(OpCodes.fltn);
	}

	/**
	 * Generates Juliet code responsible for evaluation of dynamic unique
	 * expression
	 * 
	 * @param jexpr
	 *            - Juliet code for unique operand
	 * @return Juliet code for unique expression
	 */
	public final static JulietCode genDynUniqueExpression(JulietCode jexpr) {
		JulietCode resJt = new JulietCode(JulietGen.genDynDeref(jexpr));
		// JulietCode resJt = new JulietCode(jexpr);
		return resJt.emit(OpCodes.unique).emit(OpCodes.fltn);
	}

	public final static JulietCode genDynAvgExpression(JulietCode jexpr) {
		JulietCode resJt = new JulietCode(JulietGen.genDynDeref(jexpr));
		return JulietGen.genAvgExpression(resJt);
	}

	/**
	 * Generates Juliet code responsible for evaluation of avg expression
	 * 
	 * @param jexpr
	 *            - Juliet code for avg operand
	 * @return Juliet code for avg expression
	 */
	public final static JulietCode genAvgExpression(JulietCode jexpr) {
		JulietCode resJt = new JulietCode();

		Instruction loop = new Instruction(OpCodes.endCntr);
		Instruction endSum = new Instruction(OpCodes.pop);
		Instruction empty = new Instruction(OpCodes.pop);
		Instruction end = new Instruction(OpCodes.nop);

		resJt.append(jexpr);
		// resJt.emit(OpCodes.nonEmpty);
		resJt.emit(OpCodes.ldcR_0);
		resJt.emit(OpCodes.swap);
		resJt.emit(OpCodes.dup);
		resJt.emit(OpCodes.exist);
		resJt.emit(OpCodes.braFalse, empty);
		resJt.append(JulietGen.createCounter());
		resJt.emit(loop);
		resJt.emit(OpCodes.braTrue, endSum);
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.emit(OpCodes.dyn2r);
		resJt.emit(OpCodes.bswap2);
		resJt.emit(OpCodes.addR);
		resJt.emit(OpCodes.swap);
		resJt.emit(OpCodes.incCntr);
		resJt.emit(OpCodes.bra, loop);
		resJt.emit(endSum);
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.i2r);
		resJt.emit(OpCodes.divR);
		resJt.append(JulietGen.destroyCounter());
		resJt.emit(OpCodes.bra, end);
		resJt.emit(empty);
		resJt.emit(end);
		return resJt;
	}

	// procedure call
	/**
	 * Generates Juliet code responsible for evaluation of call expression
	 * 
	 * @param callexpr
	 *            - Juliet code generating procedure reference
	 * @param params
	 *            - Juliet code evaluating params for procedure
	 * @return Juliet code for runtime procedure call
	 */
	public final static JulietCode genProcCallExpression(JulietCode callexpr, JulietCode params, int paramsNumber) {
		// JulietCode jtc = new JulietCode().append(params);
		// jtc.append(callexpr);
		// jtc.append(JulietGen.genProcedureCall());
		return genDynProcCallExpression(callexpr, params, paramsNumber);
	}

	// TW
	public final static JulietCode genExtProcCallExpression(JulietCode callexpr, JulietCode params) {
		JulietCode jtc = new JulietCode().append(params);
		jtc.append(callexpr);
		jtc.emit(OpCodes.external);
		return jtc;
	}

	/**
	 * Generates Juliet code responsible for dynamic evaluation of call
	 * expression
	 * 
	 * @param callexpr
	 *            - Juliet code generating procedure reference
	 * @param params
	 *            - Juliet code evaluating params for procedure
	 * @param paramsNumber
	 *            - number of procedure params
	 * @return Juliet code for runtime procedure call
	 */
	public final static JulietCode genDynProcCallExpression(JulietCode callexpr, JulietCode params, int paramsNumber) {
		JulietCode jtc = new JulietCode().append(params);
		jtc.emit(OpCodes.ldI, paramsNumber);
		jtc.append(callexpr);
		jtc.append(JulietGen.genProcedureCall());
		return jtc;
	}

	/**
	 * Generates Juliet code responsible for evaluation of break expression
	 * 
	 * @return Juliet code for break expression
	 */
	public final static JulietCode genBreak(int blocksToDestroy) {
		JulietCode jtc = new JulietCode();
		for (int i = 0; i < blocksToDestroy; i++) {
			jtc.append(JulietGen.genDestroyLocalEnvironment());
		}
		return jtc.emitBreakInstruction();
	}

	/**
	 * Generates Juliet code responsible for evaluation of continue expression
	 * 
	 * @return Juliet code for continue expression
	 */
	public final static JulietCode genContinue(int blocksToDestroy) {
		JulietCode jtc = new JulietCode();
		for (int i = 0; i < blocksToDestroy; i++) {
			jtc.append(JulietGen.genDestroyLocalEnvironment());
		}
		return jtc.emitContinueInstruction();
	}

	// ***************************
	// created by raist, 30.07.2006

	// /////////////////////////procedure body/////////////////////////////////
	/**
	 * Generates Juliet code responsible for evaluation of sequential statements
	 * 
	 * @param s1
	 *            - left statement
	 * @param s2
	 *            - right statement
	 * @return Juliet code for sequential statements
	 */
	public final static JulietCode genCodeSequence(JulietCode s1, JulietCode s2) {
		return s1.append(s2);
	}

	/**
	 * Generates Juliet code responsible for evaluation of expression statement
	 * 
	 * @param e
	 *            - expression
	 * @return Juliet code for expression statement
	 */
	public final static JulietCode genExpressionStatement(JulietCode e) {
		return e.emit(OpCodes.pop);
	}

	/**
	 * Generates Juliet code responsible for evaluation of procedure return
	 * without value
	 * 
	 * @param envLevel
	 *            - the number of local blocks environments currently open (must
	 *            be popped)
	 * @return Juliet code for procedure return without value
	 */
	public final static JulietCode genReturnWithoutValueStatement() {
		JulietCode jtc = new JulietCode();

		jtc.emitReturnHandle();
		return jtc.append(JulietGen.genProcedureBodyTail()).emit(OpCodes.ret);
	}

	/**
	 * Generates Juliet code responsible for evaluation of procedure return with
	 * value
	 * 
	 * @param e
	 *            - Juliet code for generating return value
	 * @return Juliet code for procedure return with value
	 */
	public final static JulietCode genReturnWithValueStatement(JulietCode e) {
		JulietCode jtc = new JulietCode();
		jtc.emitReturnHandle();
		jtc.append(e);

		return jtc.append(JulietGen.genProcedureBodyTail()).emit(OpCodes.retv);
	}

	/**
	 * Generates Juliet code responsible for evaluation of empty statement
	 * 
	 * @return Juliet code for empty statement
	 */
	public final static JulietCode genEmptyStatement() {
		return new JulietCode().emit(OpCodes.nop);
	}

	/**
	 * Generates Juliet code responsible for evaluation of empty expression
	 * (loads an empty bag)
	 * 
	 * @return Juliet code for empty statement
	 */
	public final static JulietCode genEmptyExpression() {
		return new JulietCode().emit(OpCodes.nop);
		// return new JulietCode().emit(OpCodes.ldBag);
	}

	/**
	 * Generates Juliet code responsible for evaluation of end statement
	 * 
	 * @return Juliet code for end statement
	 */
	public final static JulietCode genEndStatement() {
		return new JulietCode().emit(OpCodes.pop);
	}

	// ***************************

	// /////////////////////////coerce/////////////////////////////////////////

	/**
	 * Generates Juliet code responsible for evaluation of string to integer
	 * coerce expression
	 * 
	 * @return Juliet code for string to integer coerce expression
	 */
	public final static JulietCode genS2I() {
		return new JulietCode().emit(OpCodes.s2i);
	}

	/**
	 * Generates Juliet code responsible for evaluation of string to date coerce
	 * expression
	 * 
	 * @return Juliet code for string to date coerce expression
	 */
	public final static JulietCode genS2D() {
		return new JulietCode().emit(OpCodes.s2d);
	}

	/**
	 * Generates Juliet code responsible for evaluation of real to integer
	 * coerce expression
	 * 
	 * @return Juliet code for real to integer coerce expression
	 */
	public final static JulietCode genR2I() {
		return new JulietCode().emit(OpCodes.r2i);
	}

	/**
	 * Generates Juliet code responsible for evaluation of string to real coerce
	 * expression
	 * 
	 * @return Juliet code for string to real coerce expression
	 */
	public final static JulietCode genS2R() {
		return new JulietCode().emit(OpCodes.s2r);
	}

	/**
	 * Generates Juliet code responsible for evaluation of string to real coerce
	 * expression
	 * 
	 * @return Juliet code for string to boolean coerce expression
	 */
	public final static JulietCode genS2B() {
		return new JulietCode().emit(OpCodes.s2b);
	}

	/**
	 * Generates Juliet code responsible for evaluation of integer to real
	 * coerce expression
	 * 
	 * @return Juliet code for integer to real coerce expression
	 */
	public final static JulietCode genI2R() {
		return new JulietCode().emit(OpCodes.i2r);
	}

	/**
	 * Generates Juliet code responsible for evaluation of boolean to string
	 * coerce expression
	 * 
	 * @return Juliet code for boolean to string coerce expression
	 */
	public final static JulietCode genB2S() {
		return new JulietCode().emit(OpCodes.b2s);
	}

	/**
	 * Generates Juliet code responsible for evaluation of real to string coerce
	 * expression
	 * 
	 * @return Juliet code for real to string coerce expression
	 */
	public final static JulietCode genR2S() {
		return new JulietCode().emit(OpCodes.r2s);
	}

	/**
	 * Generates Juliet code responsible for evaluation of date to string coerce
	 * expression
	 * 
	 * @return Juliet code for date to string coerce expression
	 */
	public final static JulietCode genD2S() {
		return new JulietCode().emit(OpCodes.d2s);
	}

	/**
	 * Generates Juliet code responsible for evaluation of integer to string
	 * coerce expression
	 * 
	 * @return Juliet code for integer to string coerce expression
	 */
	public final static JulietCode genI2S() {
		return new JulietCode().emit(OpCodes.i2s);
	}

	/**
	 * Generates Juliet code responsible for evaluation of dynamic to integer
	 * coerce expression (dynamic means with runtime type checking of the
	 * operand)
	 * 
	 * @return Juliet code for dynamic to integer coerce expression
	 */
	public final static JulietCode genDyn2I() {
		return new JulietCode().emit(OpCodes.dyn2i);
	}

	/**
	 * Generates Juliet code responsible for evaluation of dynamic to real
	 * coerce expression (dynamic means with runtime type checking of the
	 * operand)
	 * 
	 * @return Juliet code for dynamic to real coerce expression
	 */
	public final static JulietCode genDyn2R() {
		return new JulietCode().emit(OpCodes.dyn2r);
	}

	/**
	 * Generates Juliet code responsible for evaluation of dynamic to date
	 * coerce expression (dynamic means with runtime type checking of the
	 * operand)
	 * 
	 * @return Juliet code for dynamic to date coerce expression
	 */
	public final static JulietCode genDyn2D() {
		return new JulietCode().emit(OpCodes.dyn2d);
	}

	/**
	 * Generates Juliet code responsible for evaluation of dynamic to boolean
	 * coerce expression (dynamic means with runtime type checking of the
	 * operand)
	 * 
	 * @return Juliet code for dynamic to boolean coerce expression
	 */
	public final static JulietCode genDyn2B() {
		return new JulietCode().emit(OpCodes.dyn2b);
	}

	/**
	 * Generates Juliet code responsible for evaluation of dynamic to string
	 * coerce expression (dynamic means with runtime type checking of the
	 * operand)
	 * 
	 * @return Juliet code for dynamic to string coerce expression
	 */
	public final static JulietCode genDyn2S() {
		return new JulietCode().emit(OpCodes.dyn2s);
	}

	/**
	 * Generates Juliet code responsible for evaluation of 'to single' result
	 * expresion
	 * 
	 * @return Juliet code for dynamic to single result expresion
	 */
	public final static JulietCode gen2Single() {
		return new JulietCode().emit(OpCodes.single);
	}

	public final static JulietCode genAssignComplexOperatorCode(MBVariable decl) throws DatabaseException {
		JulietCode resJt = new JulietCode();

		resJt.emit(OpCodes.delChildren);

		resJt.append(createObjectWithInit(decl, 1, 1, OpCodes.pop, new CreateProperties(true, true, true, false, OpCodes.pop)));

		return resJt;
	}

	// ///////////////////////////////////////////////////////////////////////

	// ////////////////////////////////helper operations//////////////////////
	public final static JulietCode genProcedureCall() {
		JulietCode resJt = new JulietCode();

		resJt.emit(OpCodes.call);

		return resJt;
	}

	public final static JulietCode genProcedureBodyTail() {
		JulietCode resJt = new JulietCode();
		// resJt.emit(OpCodes.ldLE);
		// resJt.emit(OpCodes.del);
		// resJt.emit(OpCodes.dsEnv);
		// /////////////////////////////////////////////
		return resJt;
	}

	public final static JulietCode createNestedEnvironment() {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.crnEnv);

		return resJt;
	}

	public final static JulietCode destroyNestedEnvironment() {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.dsnEnv);
		return resJt;
	}

	final static JulietCode genIterationWithCounter(JulietCode loopexecCode) {
		// iterates over the value curently on the top of the stack
		JulietCode resJt = new JulietCode();
		Instruction loop = new Instruction(OpCodes.endCntr);
		Instruction end = new Instruction(OpCodes.pop);

		resJt.append(JulietGen.createCounter());
		resJt.emit(loop);
		resJt.emit(OpCodes.braTrue, end);
		resJt.emit(OpCodes.ldCntr);
		resJt.emit(OpCodes.extr);
		resJt.append(loopexecCode);
		resJt.emit(OpCodes.incCntr);
		resJt.emit(OpCodes.bra, loop);
		resJt.emit(end);
		resJt.append(JulietGen.destroyCounter());
		return resJt;
	}

	private final static JulietCode genDerefExpression(OpCodes opcode) {
		return new JulietCode().emit(opcode);

	}

	private final static JulietCode genColDerefExpression(OpCodes opcode) {

		return new JulietCode().emit(opcode).emit(OpCodes.fltn);

	}

	public final static JulietCode genRangeExpression(JulietCode jexprl, JulietCode jexprr) {

		JulietCode resJt = new JulietCode(jexprl);
		resJt.append(jexprr);
		return resJt.emit(OpCodes.rng).emit(OpCodes.fltn);

	}

	public final static JulietCode genDynRangeExpression(JulietCode jexprl, JulietCode jexprr) {

		return genRangeExpression(jexprl, genDynDeref(jexprr)).emit(OpCodes.fltn);

	}

	public final static JulietCode genStructExpression(JulietCode jexpr) {
		JulietCode resJt = new JulietCode(jexpr);
		resJt.emit(OpCodes.tostruct);
		return resJt;

	}

	public final static JulietCode genBagExpression(JulietCode jexpr) {
		JulietCode resJt = new JulietCode(jexpr);
		resJt.emit(OpCodes.tobag);
		return resJt;

	}

	// ///////////////////////////////////////////////////////////////////////

	// ////////////////////////////////view code//////////////////////
	/**
	 * Generates Juliet code responsible for evaluation of virtual object call
	 * 
	 * @return Juliet code responsible for evaluation of virtual object call
	 * 
	 */
	public final static JulietCode genCallVirtualObjects() {

		// JulietCode resJt = new JulietCode();
		// resJt.emit(OpCodes.dup);
		// resJt.append(JulietGen.genProcedureCall());
		// resJt.emit(OpCodes.crvid);
		// resJt.emit(OpCodes.fltn);
		return genDynCallVirtualObjects();

	}

	/**
	 * Generates Juliet code responsible for evaluation of virtual object call
	 * 
	 * @return Juliet code responsible for evaluation of virtual object call
	 * 
	 */
	public final static JulietCode genDynCallVirtualObjects() {

		JulietCode resJt = new JulietCode();

		resJt.emit(OpCodes.dup);
		resJt.emit(OpCodes.ldI, 0);
		resJt.emit(OpCodes.swap);
		resJt.append(JulietGen.genProcedureCall());
		resJt.emit(OpCodes.crvid);
		resJt.emit(OpCodes.fltn);
		return resJt;

	}

	// /////////////////////////Indexing code generation/////////////////
	/**
	 * Generates Juliet code responsible for resolving index keyvalue for nonkey
	 * given on QRES (simplified dot)
	 * 
	 * @param q2Jt
	 *            - Juliet code for right dot operand
	 * @return Juliet code evaluating dot expression
	 */
	public static JulietCode genIndexKeyValueCode(JulietCode q2Jt) {
		JulietCode resJt = new JulietCode();

		resJt.append(createNestedEnvironment());
		resJt.append(q2Jt);
		resJt.append(destroyNestedEnvironment());
		resJt.emit(OpCodes.fltn);

		return resJt;
	}

	public static JulietCode genCreateVirtualReferenceCode(int name_id) {
		JulietCode code = new JulietCode();
		code.emit(OpCodes.bind, name_id);
		code.emit(OpCodes.swap);
		code.emit(OpCodes.crvid);
		code.emit(OpCodes.fltn);
		return code;
	}

	public final static JulietCode genExecSqlExpression(JulietCode sql, JulietCode pattern, JulietCode module) {
		JulietCode resJt = new JulietCode();

		resJt.append(sql);
		resJt.append(pattern);
		resJt.append(module);
		resJt.emit(OpCodes.execsql);
		return resJt.emit(OpCodes.fltn);
	}

	public final static JulietCode genDateformatExpression(JulietCode date, JulietCode format) {
		JulietCode resJt = new JulietCode();

		resJt.append(date);
		resJt.append(format);
		resJt.emit(OpCodes.dateprec);
		return resJt.emit(OpCodes.fltn);
	}

	public final static JulietCode genRandomExpression(JulietCode min, JulietCode max) {
		JulietCode resJt = new JulietCode();

		resJt.append(min);
		resJt.append(max);
		resJt.emit(OpCodes.random);
		return resJt.emit(OpCodes.fltn);
	}

	public final static JulietCode genRandomExpression(JulietCode collection) {
		JulietCode resJt = new JulietCode();

		resJt.append(collection);
		resJt.emit(OpCodes.randomObj);
		return resJt.emit(OpCodes.fltn);
	}

	public final static JulietCode genEmptyBag() {
		return new JulietCode().emit(OpCodes.ldBag);
	}

	public final static JulietCode genInstanceofExpression(JulietCode lJtCode, JulietCode rJtCode) {
		JulietCode resJt = new JulietCode(lJtCode);
		resJt.append(rJtCode);

		return resJt.emit(OpCodes.instof);
	}

	public final static JulietCode genClassCastExpression(JulietCode lJtCode, JulietCode rJtCode) {
		JulietCode resJt = new JulietCode(lJtCode);
		resJt.append(rJtCode);

		return resJt.emit(OpCodes.castClass).emit(OpCodes.fltn);
	}

	public final static JulietCode genDynCastExpression(JulietCode lJtCode, JulietCode rJtCode) {
		JulietCode resJt = new JulietCode(lJtCode);
		resJt.append(rJtCode);

		return resJt.emit(OpCodes.dynCast).emit(OpCodes.fltn);
	}

	public static JulietCode genBeginTransForMBObject(ITransactionCapableMBObject mbObject) {
		JulietCode resJulietCode = new JulietCode();
		if (mbObject.isTransactionCapable()) {
			resJulietCode.emit(OpCodes.beginTrans);
		}
		return resJulietCode;
	}

	public static JulietCode genCommitTrans(JulietCode code) {
		JulietCode resJulietCode = new JulietCode(code);
		resJulietCode.emit(OpCodes.commitTrans);
		return resJulietCode;
	}

	public static JulietCode genAtMostCardinality(JulietCode code, int limit) {
		JulietCode resJulietCode = new JulietCode(code);
		resJulietCode.emit(OpCodes.atmost, limit);
		return resJulietCode;
	}

	public static JulietCode genAtLeastCardinality(JulietCode code, int limit) {
		JulietCode resJulietCode = new JulietCode(code);
		resJulietCode.emit(OpCodes.atleast, limit);
		return resJulietCode;
	}


	public static JulietCode genLazyFailureExpression(JulietCode code) {
		Instruction endLazyFailureBlock = new Instruction(OpCodes.endLazyFailure);
		JulietCode resJulietCode = new JulietCode().emit(OpCodes.beginLazyFailure, endLazyFailureBlock); 
		resJulietCode.append(new JulietCode(code));
		resJulietCode.emit(endLazyFailureBlock);
		return resJulietCode;
	}
	
	public static JulietCode genRemoteQuery(int query, int lname, int host, int schema, int port, int username, int paramCount, int asynchronous_id)
			throws DatabaseException

	{
		JulietCode resJt = new JulietCode();

		// no parms.
		resJt.emit(OpCodes.ldI, paramCount);

		// query
		resJt.emit(OpCodes.ldcS, query);

		// link parms
		resJt.emit(OpCodes.ldcS, lname);
		resJt.emit(OpCodes.ldcS, host);
		resJt.emit(OpCodes.ldcS, schema);
		resJt.emit(OpCodes.ldI, port);

		if (asynchronous_id < 0)
			resJt.emit(OpCodes.remoteQuery);
		else
			resJt.emit(OpCodes.remoteAsyncQuery, asynchronous_id);

		return resJt;
	}

	/**
	 * generate code for remote procedure call
	 * 
	 * @param paramsNumber
	 *            - number of procedure params
	 * @return
	 */
	public static JulietCode genRemoteCall(int paramsNumber) {
		JulietCode resJt = new JulietCode();
		// TODO separate remote call opcode
		resJt.emit(OpCodes.ldI, paramsNumber);
		resJt.emit(OpCodes.swap);
		resJt.append(JulietGen.genProcedureCall());
		resJt.emit(OpCodes.fltn);
		return resJt;

	}

	public static JulietCode genTryCatchFinally(JulietCode tryCode, JulietCode[] catchBlocks, JulietCode finallyCode) {
		JulietCode resJt = new JulietCode();
		Instruction end = new Instruction(OpCodes.nop);
		tryCode.fixReturn(finallyCode);
		resJt.append(tryCode);
		resJt.append(finallyCode.copy());
		resJt.emit(OpCodes.bra, end);

		for (JulietCode blockJt : catchBlocks) {
			blockJt.fixReturn(finallyCode);
			resJt.append(blockJt);
			resJt.append(finallyCode.copy());
			resJt.emit(OpCodes.bra, end);

		}
		finallyCode.fixReturn(new JulietCode().emit(OpCodes.pop));
		resJt.append(finallyCode.emit(OpCodes.athrow));
		resJt.emit(end);

		return resJt;
	}

	public static JulietCode genCatchBlock(int exceptionNameId, JulietCode catchStmt) {
		JulietCode resJt = new JulietCode();
		// local environment will be created by the exception hander
		resJt.emit(OpCodes.enterBinder, exceptionNameId);
		resJt.emit(OpCodes.initLoc);
		resJt.append(catchStmt);
		resJt.append(JulietGen.genDestroyLocalEnvironment());
		return resJt;
	}

	public static JulietCode genThrowStatement(JulietCode exprJt) {
		JulietCode resJt = new JulietCode(exprJt);
		resJt.emit(OpCodes.athrow);
		return resJt;
	}

	public static JulietCode genParallelUnionExpression(ArrayList<JulietCode> parallelExpressionsJulietCodes, int asynchronous_id) {
		JulietCode resJt = new JulietCode();
		for (JulietCode subCode : parallelExpressionsJulietCodes)
			resJt.append(subCode);

		return resJt.emit(OpCodes.waitForAsync, asynchronous_id).emit(OpCodes.ldI, parallelExpressionsJulietCodes.size()).emit(OpCodes.parallelUnion)
				.emit(OpCodes.fltn);
	}

	final static JulietCode createCounter() {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.dup);
		resJt.emit(OpCodes.cnt);
		resJt.emit(OpCodes.crCntr);
		return resJt;
	}

	final static JulietCode destroyCounter() {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.dsEnv);
		return resJt;
	}

	/**
	 * @param julietCode
	 * @param value
	 */
	public static JulietCode getRangeAs(JulietCode julietCode, int nameid) {
		JulietCode resJt = new JulietCode();

		JulietCode inLoop = new JulietCode();
		inLoop.emit(OpCodes.ldCntr);
		inLoop.emit(OpCodes.ldI, 1);
		inLoop.emit(OpCodes.addI); // because we range from 1 and the counter
									// counts from 0
		inLoop.emit(OpCodes.as, nameid);
		inLoop.emit(OpCodes.crpd);
		inLoop.emit(OpCodes.insPrt2);

		resJt.emit(OpCodes.ldBag);
		resJt.append(julietCode);
		resJt.append(JulietGen.genIterationWithCounter(inLoop));
		resJt.emit(OpCodes.fltn);

		return resJt;
	}

	/**
	 * @param jtExpr
	 * @return
	 */
	public static JulietCode getSerializeOIDExpression(JulietCode jtExpr) {
		JulietCode resJt = new JulietCode();
		resJt.append(jtExpr);
		resJt.emit(OpCodes.serializeOID);
		resJt.emit(OpCodes.fltn);
		return resJt;
	}

	/**
	 * @param julietCode
	 *            - code of the operand TODO Runtime Typecheck
	 * @return
	 */
	public static JulietCode genDeserializeOID(JulietCode typeExpr, JulietCode jtExpr) {
		JulietCode resJt = new JulietCode();
		resJt.append(jtExpr);
		resJt.emit(OpCodes.deserializeOID);
		resJt.emit(OpCodes.fltn);
		return resJt;
	}

	/**
	 * @param opcode
	 * @return opcode wrapped into JulietCode
	 */
	public static JulietCode getJulietForOpCode(OpCodes opcode) {

		return new JulietCode().emit(opcode);
	}

	/**
	 * @param typeid
	 * @param nameid
	 * @param stringid
	 */
	public static JulietCode genParamDependent(int typeid, int nameid, int stringid) {
		JulietCode resJt = new JulietCode();
		resJt.emit(OpCodes.ldI, typeid);
		resJt.emit(OpCodes.bind, nameid);
		resJt.emit(OpCodes.ldcS, stringid);
		return resJt;
	}

	public static JulietCode genRename(int nameid, JulietCode parJt) {
		JulietCode resJt = new JulietCode(parJt);
		resJt.emit(OpCodes.bindAgg, nameid);
		resJt.emit(OpCodes.rename);
		return resJt;
	}

	public static JulietCode genColRename(int nameid, JulietCode parJt) {
		JulietCode resJt = new JulietCode(parJt);
		resJt.emit(OpCodes.bindAgg, nameid);
		resJt.emit(OpCodes.colRename);

		resJt.emit(OpCodes.fltn);
		return resJt;
	}

	/**
	 * @param minCard
	 * @param maxCard
	 * @return
	 */
	private static boolean isSingle(int minCard, int maxCard) {
		assert minCard <= maxCard : "minCard <= maxCard";
		return !(minCard != 1 || maxCard != 1);
	}

	private static class CreateProperties {

		/**
		 * true if the code to be generate can be safe (typechecked before
		 * generation)
		 */
		private boolean safe;

		/**
		 *  
		 */
		private boolean alwaysAggregate;
		/**
		 * true if only the code for creating interior of an (complex) object
		 * must be generated the required cardinality is [1..1]
		 */
		private boolean createOnlyInterior;

		/**
		 * true if the (aggregate) parent for the object being created is on the
		 * top of QRES. False if we need standard way (the parent aggregate
		 * object has to be found inside the complex object: see crAgg, crAgg...
		 * opcodes)
		 */
		private boolean aggregateOnTheStack;

		/**
		 * the opcode to execute when the object is created and reference to it
		 * is on the QRES top
		 */
		private OpCodes resultOpCode;
		private Map<OID, Instruction> marked;

		/**
		 * @param safe
		 * @param alwaysAggregate
		 * @param createOnlyInterior
		 */
		CreateProperties(boolean safe, boolean alwaysAggregate, boolean createOnlyInterior, boolean aggregateOnTheStack, OpCodes resultOpCode) {
			this(safe, alwaysAggregate, createOnlyInterior, aggregateOnTheStack, resultOpCode, new HashMap<OID, Instruction>());
		}

		/**
		 * @param safe
		 * @param alwaysAggregate
		 * @param createOnlyInterior
		 * @param marked
		 * @param resultOpCode
		 */
		public CreateProperties(boolean safe, boolean alwaysAggregate, boolean createOnlyInterior, boolean aggregateOnTheStack, OpCodes resultOpCode,
				Map<OID, Instruction> marked) {
			this.safe = safe;
			this.alwaysAggregate = alwaysAggregate;
			this.createOnlyInterior = createOnlyInterior;
			this.aggregateOnTheStack = aggregateOnTheStack;
			this.resultOpCode = resultOpCode;
			this.marked = marked;
		}

	}

	/**
	 * @param enameid
	 * @return
	 * @throws DatabaseException
	 */
	public static JulietCode genBind(int nameid) throws DatabaseException {
		return new JulietCode().emit(OpCodes.bind, nameid).emit(OpCodes.fltn);
	}

}
