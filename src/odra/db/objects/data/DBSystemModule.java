package odra.db.objects.data;

import java.util.Date;

import odra.db.DatabaseException;
import odra.db.OID;
import odra.db.objects.meta.MBBinaryOperator;
import odra.db.objects.meta.MBPrimitiveType;
import odra.db.objects.meta.MBTypeDef;
import odra.db.objects.meta.MBUnaryOperator;
import odra.system.config.ConfigDebug;

/**
 * This class represents a special purpose module.
 * Every database contains a single system module.
 * Such a module is the root of every database.
 * Other modules of the database are its submodules.
 * 
 * The main responsiblity of the system module is to store
 * the base environment.
 * 
 * @author raist
 */

public class DBSystemModule extends DBModule {
	/**
	 * Initializes the DBSystemModule object by providing an OID of an existing object
	 * @param moid OID of the object
	 */
	public DBSystemModule(OID moid) throws DatabaseException {	
		super(moid);
		
		if (ConfigDebug.ASSERTS) assert oid.isComplexObject();		
	}

	/**
	 * @return global name of the module
	 */
	protected String determineGlobalName() throws DatabaseException {
		return "system";
	}

	/**
	 * @return global name of the module
	 */
	public String getGlobalModuleName() throws DatabaseException {
		return "system";
	}
	
	/**
	 * @return name of the module
	 */
	public String getModuleName() throws DatabaseException {
		return "system";
	}
	
	/**
	 * Creates a new integer type
	 * @param name external name of the integer type
	 * @return OID of the meta-type
	 */
	public OID createIntegerType(String name) throws DatabaseException {
	    OID oid = this.findFirstByName(name, this.getDatabaseEntry());
	    if(oid == null)
		store.createIntegerObject(store.addName(name), this.getDatabaseEntry(), 0);
	   return this.createType(name); 
	}
	
	/**
	 * Creates a new string type
	 * @param name external name of the string type
	 * @return OID of the meta-type
	 */
	public OID createStringType(String name) throws DatabaseException {
	    OID oid = this.findFirstByName(name, this.getDatabaseEntry());
	    if(oid == null)
		store.createStringObject(store.addName(name), this.getDatabaseEntry(), "",0);
	   return this.createType(name); 
	}
	/**
	 * Creates a new Void type
	 * @param name external name of the Void type
	 * @return OID of the meta-type
	 */
	public OID createVoidType(String name) throws DatabaseException {
	   return this.createType(name); 
	}
	
	/**
	 * Creates a new Real type
	 * @param name external name of the Real type
	 * @return OID of the meta-type
	 */
	public OID createRealType(String name) throws DatabaseException {
	    OID oid = this.findFirstByName(name, this.getDatabaseEntry());
	    if(oid == null)
		store.createDoubleObject(store.addName(name), this.getDatabaseEntry(), 0);
	   return this.createType(name); 
	}
	/**
	 * Creates a new Date type
	 * @param name external name of the Date type
	 * @return OID of the meta-type
	 */
	public OID createDateType(String name) throws DatabaseException {
	    OID oid = this.findFirstByName(name, this.getDatabaseEntry());
	    if(oid == null)
		store.createDateObject(store.addName(name), this.getDatabaseEntry(), new Date());
	   return this.createType(name); 
	}
	
	/**
	 * Creates a new Boolean type
	 * @param name external name of the Boolean type
	 * @return OID of the meta-type
	 */
	public OID createBooleanType(String name) throws DatabaseException {
	    OID oid = this.findFirstByName(name, this.getDatabaseEntry());
	    if(oid == null)
		store.createBooleanObject(store.addName(name), this.getDatabaseEntry(), true);
	   return this.createType(name); 
	}
	
	/**
	 * Creates a new primitive type
	 * @param name name of the type
	 * @return OID of the type
	 */
	private OID createType(String name) throws DatabaseException {
		OID oid = this.findFirstByName(name, this.getMetabaseEntry());
		
		if (oid != null)
			return oid;

		OID typeid = store.createComplexObject(store.addName(name), this.getMetaRef(), 2);
		new MBPrimitiveType(typeid).initialize(name);
	
		return typeid;		
	}

	/**
	 * Creates a new record describing a binary operator.
	 * @param terminal textual version of the operator (e.g. "+")
	 * @param resType pointer to a primitive type being the result of the operator
	 * @param leftType pointer to a primitive type being the left operand
	 * @param rightType pointer to a primitive type being the right operand
	 * @param leftCoercion pointer to a primitive type to which the left-hand side should be coerced before the operator can be applied
	 * @param rightCoercion pointer to a primitive type to which the right-hand side should be coerced
	 * @param opcode opcode which should be generated by the code emiter to provide functionality of the operator in the binary code
	 * @return OID of the operator
	 */
	public OID createBinaryOperator(String terminal, OID resType, OID leftType, OID rightType, OID leftCoercion, OID rightCoercion, int opcode) throws DatabaseException {		
		OID agg = findFirstByName(terminal, this.getMetabaseEntry());

		if (agg == null)
			agg = this.createAggregateObject(terminal, this.getMetaRef(), 0);

		OID oid = findBinaryOperator(terminal, agg, resType, leftType, rightType, leftCoercion, rightCoercion, opcode);

		if (oid != null)
			return oid;

		OID operatorid = store.createComplexObject(store.addName(terminal), agg, 0);
		new MBBinaryOperator(operatorid).initialize(terminal, resType, leftType, rightType, leftCoercion, rightCoercion, opcode);

		return null;
	}

	/**
	 * Creates a new record describing a unary operator.
	 * @param terminal textual version of the operator (e.g. "+")
	 * @param resType pointer to a primitive type being the result of the operator
	 * @param argType pointer to a primitive type being the argument of the operator
	 * @param opcode opcode which should be generated by the code emiter to provide functionality of the operator in the binary code
	 * @return OID of the operator
	 */
	public OID createUnaryOperator(String terminal, OID resType, OID argType, int opcode) throws DatabaseException {
		OID agg = findFirstByName(terminal, this.getMetabaseEntry());

		if (agg == null)
			agg = this.createAggregateObject(terminal, this.getMetaRef(), 0);
		
		OID oid = findUnaryOperator(terminal, agg, resType, argType, opcode);

		if (oid != null)
			return oid;
		
		OID operatorid = store.createComplexObject(store.addName(terminal), agg, 0);
		new MBUnaryOperator(operatorid).initialize(terminal, resType, argType, opcode);

		return operatorid;
	}
	
	/**
	 * Tries to find a binary operator having a particular characteristic.
	 */
	private OID findBinaryOperator(String terminal, OID agg, OID resType, OID leftType, OID rightType, OID leftCoercion, OID rightCoercion, int opcode) throws DatabaseException {		
		OID[] ops = agg.derefComplex();
		
		for (OID op : ops) {
			MBBinaryOperator bop = new MBBinaryOperator(op);

			if (bop.isValid() && bop.getOpCode() == opcode 
					&& bop.getResultType().equals(resType)
					&& bop.getLeftType().equals(leftType) 
					&& bop.getRightType().equals(rightType) )
				return op;
		}

		return null;
	}

	/**
	 * Tries to find a unary operator having a particular characteristic.
	 */
	private OID findUnaryOperator(String terminal, OID agg, OID resType, OID argType, int opcode) throws DatabaseException {
		OID[] ops = agg.derefComplex();

		for (OID op : ops) {
			MBUnaryOperator uop = new MBUnaryOperator(op);

			if (uop.isValid() && uop.getOpCode() == opcode)
				return op;
		}

		return null;
	}

	/**
	 * Creates typedefs representing special types (eg.serialized oids type)
	 * @param name - type name
	 * @param representation - type representation (eg. string, integer)
	 * @return 
	 * @throws DatabaseException 
	 */
	public OID createNamedSpecialType(String name, String representation) throws DatabaseException {
		OID oid = this.findFirstByName(name, this.getDatabaseEntry());
	    if(oid == null) {
	    	int typenameid = this.addMetaReference(representation);
	    	OID typeid = store.createComplexObject(store.addName(name), this.getMetaRef(), MBTypeDef.FIELD_COUNT);
			new MBTypeDef(typeid).initialize(typenameid, true);
			return typeid;
	    }
		return null;
	}
}
